<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行之技术博客</title>
    <description>Linux / C / golang / Emacs</description>
    <link>http://xep007.github.io/</link>
    <atom:link href="http://xep007.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 03 Dec 2014 22:49:23 +0800</pubDate>
    <lastBuildDate>Wed, 03 Dec 2014 22:49:23 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>编译安装freshplayerplugin解决firefox上flashplayer版本过低问题</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 先安装编译所需的库文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. git clone freshplayerplugin并编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. 重启firefox&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;
最近在网易云课堂学习。firefox上的flashplayer插件是adobe官网上下载的，版本号是11.2，低于11.4，因而无法播放网易云课堂上的课件。升级版本吧，但是adobe已经不再升级linux上的flash插件了，锁定在11.2了。怎么办？
&lt;/p&gt;

&lt;p&gt;
搜索了一通之后，发现了一个&lt;a href=&quot;https://github.com/i-rinat/freshplayerplugin&quot;&gt;网站&lt;/a&gt;，提供了解决办法。
&lt;/p&gt;

&lt;p&gt;
底下简单地把安装过程介绍一下。
&lt;/p&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 先安装编译所需的库文件&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;pre class=&quot;example&quot;&gt;
sudo aptitude install cmake pkg-config ragel libasound2-dev libglib2.0-dev libconfig-dev \
       libpango1.0-dev libegl1-mesa-dev libevent-dev libgtk2.0-dev libgles2-mesa-dev
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; git clone freshplayerplugin并编译&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;pre class=&quot;example&quot;&gt;
git clone https://github.com/i-rinat/freshplayerplugin

cd freshplayerplugin/src

cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..

make

cp libfreshwrapper-pepperflash.so ~/.mozilla/plugins
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; 重启firefox&lt;/h2&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 03 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/firefox/2014/12/03/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85freshplayerplugin%E8%A7%A3%E5%86%B3firefox%E4%B8%8Aflash%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">http://xep007.github.io/firefox/2014/12/03/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85freshplayerplugin%E8%A7%A3%E5%86%B3firefox%E4%B8%8Aflash%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E%E9%97%AE%E9%A2%98.html</guid>
        
        <category>firefox</category>
        
        
        <category>firefox</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（十四）——过程式编程之自定义函数</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 自定义函数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. 函数参数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-1&quot;&gt;1.1.1. 将函数调用作为函数的参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-2&quot;&gt;1.1.2. 可变参数函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-3&quot;&gt;1.1.3. 可选参数的函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. init()函数和main()函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 闭包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. 递归函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5&quot;&gt;1.5. 运行时选择函数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5-1&quot;&gt;1.5.1. 使用映射和函数引用来制造分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5-2&quot;&gt;1.5.2. 动态函数的创建&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6&quot;&gt;1.6. 高阶函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 自定义函数&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
基本语法
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;functionName&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;optionalParameters&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;optionalReturnType&lt;/span&gt; {
    body
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;functionName&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;optionalParameters&lt;/span&gt;) (&lt;span style=&quot;color: #ffff00;&quot;&gt;optionalReturnValues&lt;/span&gt;) {
    body
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
函数可以有任意多个参数，如果无参数，则圆括号是空的。否则就要写成：(params1 type1, params2 type2, &amp;#x2026; paramsN typeN)，参数加参数类型。参数之间用逗号隔开。参数需按给定的顺序来传递。
&lt;/p&gt;

&lt;p&gt;
如果多个参数为同一类型，可以这样写：(params1, params2, &amp;#x2026; paramsN typeN)。
&lt;/p&gt;

&lt;p&gt;
可变参数，要实现可变参数，可以在参数之后加上省略号(args&amp;#x2026;int)，如果既有可变参数，也有固定参数，那么可变参数要放在最后面。
&lt;/p&gt;

&lt;p&gt;
函数的返回值跟参数相类。如没有返回值，就在参数列表之后紧跟右大括号。
&lt;/p&gt;

&lt;p&gt;
如果有返回值，就跟在参数列表之后，有两个或以上的返回值应加括号并且用逗号分隔，只有一个返回值的可加也可不加括号。返回值可设置成返回值命名加返回值类型，也可省略命名。但不可只为部分返回值命名。
&lt;/p&gt;

&lt;p&gt;
如果函数有返回值，则函数主体必须至少有一个return语句或最后执行panic()调用。如果返回值是未命名的，则return语句必须指定和返回值列表一样多的值。如果返回值是命名的，则return语句可以像没有命名的返回值方式或者是一个空的return语句。一般来说，不要使用空的return语句。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; 函数参数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
上面介绍的函数参数要么是固定参数，要么是可变参数，其实还有一种类型参数是interface{}，表示我们可以传递任何类型的数据。这将在第6章介绍。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.1&lt;/span&gt; 将函数调用作为函数的参数&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-1&quot;&gt;
&lt;p&gt;
如果我们有一个函数或方法，接收一个或多个参数，我们可以直接调用它并给它相应的参数。另外，我们也可将其他函数或方法调用作为一个函数的参数，只要该作为参数的函数或方法的返回值个数和类型与调用函数的列表匹配即可。
&lt;/p&gt;

&lt;p&gt;
来个例子：一个函数要求传入三角形的边长（以整数的方式），然后使用海伦公式计算出三角形的面积。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;math&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := 1; i &amp;lt;= 4; i++ {
                a, b, c := &lt;span style=&quot;color: #00fa9a;&quot;&gt;PythagoreanTriple&lt;/span&gt;(i, i+1)
                &amp;#916;1 := &lt;span style=&quot;color: #00fa9a;&quot;&gt;Heron&lt;/span&gt;(a, b, c)
                &amp;#916;2 := &lt;span style=&quot;color: #00fa9a;&quot;&gt;Heron&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;PythagoreanTriple&lt;/span&gt;(i, i+1))
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;&amp;#916;1== %10f == &amp;#916;2 == %10f\n&quot;&lt;/span&gt;, &amp;#916;1, &amp;#916;2)
        }
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;Heron&lt;/span&gt;(a, b, c &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;float64&lt;/span&gt; {
        A, B, C := &lt;span style=&quot;color: #00fa9a;&quot;&gt;float64&lt;/span&gt;(a), &lt;span style=&quot;color: #00fa9a;&quot;&gt;float64&lt;/span&gt;(b), &lt;span style=&quot;color: #00fa9a;&quot;&gt;float64&lt;/span&gt;(c)
        s := (A + B + C) / 2
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; math.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Sqrt&lt;/span&gt;(s * (s - A) * (s - B) * (s - C))
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;PythagoreanTriple&lt;/span&gt;(m, n &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) (a, b, c &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; m &amp;lt; n {
                m, n = n, m
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; (m * m) - (n * n), (2 * m * n), (m * m) + (n * n)
}
&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&amp;#916;1==   6.000000 == &amp;#916;2 ==   6.000000
&amp;#916;1==  30.000000 == &amp;#916;2 ==  30.000000
&amp;#916;1==  84.000000 == &amp;#916;2 ==  84.000000
&amp;#916;1== 180.000000 == &amp;#916;2 == 180.000000
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.2&lt;/span&gt; 可变参数函数&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-2&quot;&gt;
&lt;p&gt;
所谓可变参数函数是指函数的最后一个参数可以接受任意多个参数。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        numbers := []&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{7, 6, 2, -1, 7, -3, 9}
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;MinimumInt1&lt;/span&gt;(numbers[0], numbers[1:]...))
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;MinimumInt1&lt;/span&gt;(first &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, rest ...&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; _, x := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; rest {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; x &amp;lt; first {
                        first = x
                }
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; first
}
&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
-3
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1-3&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-3&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.3&lt;/span&gt; 可选参数的函数&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-3&quot;&gt;
&lt;p&gt;
Go语言并没有直接支持可选参数。但是，实现很容易，只需增加一个额外的结构体即可。而且Go语言能保证所有的值都会被初始化为零值。
&lt;/p&gt;

&lt;p&gt;
假设我们有一个函数用来处理一些自定义的数据，默认就是简单地处理所有的数据，但有些时候我们希望可以指定处理第一个或最后一个项，还是是否记录函数的行为，或对于非法的项做处理，等等。
&lt;/p&gt;

&lt;p&gt;
一个办法就是创建一个签名为ProcessItems(items Items, first, last int, audit bool, errorHandler func(item Item))的函数。如果last的值为0就意味着需要取到最后一个item而不管这个索引值。而errorHandler函数只有在不为nil时才会被调用。也就是说，不管在哪调用它，如果希望默认行为的话，只需要写ProcessItems(items, 0, 0, false, nil)就可以了。
&lt;/p&gt;

&lt;p&gt;
一个比较优雅的做法就是这样定义函数ProcessItems(items Items, options Options),其中Options结构体保存了其他所有参数，初始值都为零值。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&amp;#20808;&amp;#35774;&amp;#32622;&amp;#32467;&amp;#26500;&amp;#20307;&amp;#12290;

&lt;span style=&quot;color: #00ffff;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;Options&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;struct&lt;/span&gt; {
    First            int                          &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#35201;&amp;#22788;&amp;#29702;&amp;#30340;&amp;#31532;&amp;#19968;&amp;#39033;&lt;/span&gt;
    Last             int                          &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#35201;&amp;#22788;&amp;#29702;&amp;#30340;&amp;#26368;&amp;#21518;&amp;#19968;&amp;#39033;&lt;/span&gt;
    Audit            bool                         &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#22914;&amp;#26524;&amp;#20026;true,&amp;#25152;&amp;#26377;&amp;#21160;&amp;#20316;&amp;#37117;&amp;#34987;&amp;#35760;&amp;#24405;&lt;/span&gt;
    ErrorHandler     &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(item &lt;span style=&quot;color: #ffff00;&quot;&gt;Item&lt;/span&gt;)              &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#22914;&amp;#26524;&amp;#19981;&amp;#26159;nil,&amp;#23545;&amp;#27599;&amp;#19968;&amp;#20010;&amp;#22351;&amp;#39033;&amp;#35843;&amp;#29992;&amp;#19968;&amp;#27425;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&amp;#35843;&amp;#29992;&amp;#65306;

&lt;span style=&quot;color: #00fa9a;&quot;&gt;ProcessItems&lt;/span&gt;(items, &lt;span style=&quot;color: #ffff00;&quot;&gt;Options&lt;/span&gt;{})
errorHandler := &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(item &lt;span style=&quot;color: #ffff00;&quot;&gt;Item&lt;/span&gt;) { log.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Invalid:&quot;&lt;/span&gt;, item)}
&lt;span style=&quot;color: #00fa9a;&quot;&gt;ProcessItems&lt;/span&gt;(items, &lt;span style=&quot;color: #ffff00;&quot;&gt;Options&lt;/span&gt;{Audit: &lt;span style=&quot;color: #fa8072;&quot;&gt;true&lt;/span&gt;, ErrorHandler: errorHandler})
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; init()函数和main()函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
Go语言有两个特殊的函数：init()和main()函数。init()函数可以出现在任何的包里，main()函数只在main包里。这两个函数既不接收任何参数，也不返回任何结果。init()函数和main()函数是自动执行的，不应该显式调用它们。对程序或包来说，init()函数是可选的，但每一个程序必须在main包里包含一个main()函数。
&lt;/p&gt;

&lt;p&gt;
Go程序的初始化和执行总是从main包开始，如果main包里导入了其他的包，则会按顺序将它们包含进main包里。如果一个包被其他的包多次导入的话，这个包实际上只会被导入一次。当一个包被导入时，如果它自己还导入了其他的包，则还是先将其他的导入进来，然后再创建这个包的一些常量和变量。再接着就是调用init()函数了，如果有多个就调用多次，最终所有的包都会被导入到main()包里，这时候main这个包的常量和变量也会被创建，init()函数会被执行。最后main包里的main()函数会被执行，程序开始运行。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 闭包&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
所谓闭包就是一个函数“捕获”了和它在同一作用域的其他常量和变量。这就意味着当闭包被调用的时候，不管在程序什么地方调用，闭包能够使用这些常量或变量。它不关心这些捕获了的变量和常量是否已经超出了作用域，所以只要闭包还在使用它，这些变量就不会存在。
&lt;/p&gt;

&lt;p&gt;
在Go语言里，所有的匿名函数都是闭包。
&lt;/p&gt;

&lt;p&gt;
闭包的创建方式和普通函数在语法上几乎一模一样，但有一个关键的区别：闭包没有名字（func关键字之后紧接着左括号）。通常都是通过闭包赋值给一个变量来使用闭包，或者将它放到一个数据结构里（如映射或切片）。
&lt;/p&gt;

&lt;p&gt;
闭包的一种用法就是利用包装函数来为被包装函数预定义一到多个参数。例如，假如我们想给大量文件增加不同后缀，本质上就是要包装string的+连接操作符，一个参数会不断变化（文件名）而另一个参数为固定值（后缀名）。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;addPng := &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(name &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {&lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; name + &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.png&quot;&lt;/span&gt;}
addJpg := &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(name &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {&lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; name + &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.jpg&quot;&lt;/span&gt;}
fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;addPng&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;filename&quot;&lt;/span&gt;), &lt;span style=&quot;color: #00fa9a;&quot;&gt;addJpg&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;filename&quot;&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
在实际环境中当我们需要创建许多类似的函数时，我们会使用一个工厂函数（factory function）,工厂函数返回一个函数。下面是一个例子：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;MakeAddSuffix&lt;/span&gt;(suffix &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {
    &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(name &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {
    &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; !strings.&lt;span style=&quot;color: #00fa9a;&quot;&gt;HasSuffix&lt;/span&gt;(name, suffix) {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; name + suffix
    }
    &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; name
   }
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
工厂函数MakeAddSuffix()返回的闭包在创建时捕获了suffix变量。这个返回的闭包接收一个字符串参数（如文件名）并返回添加了被捕获的suffix后缀的文件名。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;addZip := &lt;span style=&quot;color: #00fa9a;&quot;&gt;MakeAddSuffix&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.zip&quot;&lt;/span&gt;)
addTgz := &lt;span style=&quot;color: #00fa9a;&quot;&gt;MakeAddSuffix&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar.gz&quot;&lt;/span&gt;)
fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;addTgz&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;filename&quot;&lt;/span&gt;), &lt;span style=&quot;color: #00fa9a;&quot;&gt;addZip&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;filename&quot;&lt;/span&gt;), &lt;span style=&quot;color: #00fa9a;&quot;&gt;addZip&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;gobook.zip&quot;&lt;/span&gt;))
&amp;#36755;&amp;#20986;&amp;#30340;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
filename.tar.gz filename.zip gobook.zip
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; 递归函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
递归函数就是调用自己的函数，相互递归就是相互调用对方的函数。
&lt;/p&gt;

&lt;p&gt;
递归函数通常有相同的结构：一个跳出条件和一个递归体。
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;递归函数：斐波那契数列
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;Fibonacci&lt;/span&gt;(n &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; n &amp;lt; 2 {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; n
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;Fibonacci&lt;/span&gt;(n-1) + &lt;span style=&quot;color: #00fa9a;&quot;&gt;Fibonacci&lt;/span&gt;(n-2)
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := 0; i &amp;lt; 20; i++ {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Print&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;Fibonacci&lt;/span&gt;(i), &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot; &quot;&lt;/span&gt;)
        }
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;()
}
&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;相互递归函数。下面代码会将每个序列中的前20个整数打印出来。
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        females := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, 20)
        males := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(females))
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; n := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; females {
                females[n] = &lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterFemale&lt;/span&gt;(n)
                males[n] = &lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterMale&lt;/span&gt;(n)
        }
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, females)
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;M&quot;&lt;/span&gt;, males)

}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterFemale&lt;/span&gt;(n &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; n &amp;lt;= 0 {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; 1
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; n - &lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterMale&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterFemale&lt;/span&gt;(n-1))
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterMale&lt;/span&gt;(n &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; n &amp;lt;= 0 {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; 0
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; n - &lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterFemale&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;HofstadterMale&lt;/span&gt;(n-1))
}
&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
F [1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12]
M [0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12]
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;判断回文的递归实现
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main
&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;unicode/utf8&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        s := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;abc&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;abcdcba&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;1234554321&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;&amp;#22825;&amp;#36830;&amp;#27700;&amp;#23614;&amp;#27700;&amp;#36830;&amp;#22825;&quot;&lt;/span&gt;}
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; _, str := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; s {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;IsPalindrome&lt;/span&gt;(str) {
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%s is palindrome\n&quot;&lt;/span&gt;, str)
                } &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; {
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%s is not palindrome\n&quot;&lt;/span&gt;, str)
                }

        }
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;IsPalindrome&lt;/span&gt;(word &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; utf8.&lt;span style=&quot;color: #00fa9a;&quot;&gt;RuneCountInString&lt;/span&gt;(word) &amp;lt;= 1 {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;true&lt;/span&gt;
        }
        first, sizeOfFirst := utf8.&lt;span style=&quot;color: #00fa9a;&quot;&gt;DecodeRuneInString&lt;/span&gt;(word)
        last, sizeOfLast := utf8.&lt;span style=&quot;color: #00fa9a;&quot;&gt;DecodeLastRuneInString&lt;/span&gt;(word)
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; first != last {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;false&lt;/span&gt;
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;IsPalindrome&lt;/span&gt;(word[sizeOfFirst : &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(word)-sizeOfLast])
}

&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
abc is not palindrome
abcdcba is palindrome
1234554321 is palindrome
&amp;#22825;&amp;#36830;&amp;#27700;&amp;#23614;&amp;#27700;&amp;#36830;&amp;#22825; is palindrome
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
utf8.DecodeRuneInString()函数，返回字符串的第一个字符（rune类型）和占用的字节数。utf8.DecodeLastRuneInString()函数相似，作用于最后一个字符，利用这两个大小，可以安全地将每个字符都切割出来。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-5&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.5&lt;/span&gt; 运行时选择函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-5&quot;&gt;
&lt;p&gt;
在Go语言中，函数是第一类值，你可以将它保存到一个变量（实际上是个引用），这样我们就可以在运行时决定要执行哪个函数。再者，Go语言能创建闭包意味着我们可以在运行时创建函数，所以我们对同一个函数可以有两个或多个不同的实现（例如不同的算法），在使用时创建它们其中一个就行。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-5-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-5-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.5.1&lt;/span&gt; 使用映射和函数引用来制造分支&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-5-1&quot;&gt;
&lt;p&gt;
&lt;b&gt;新版ArchiverFileLIst()&lt;/b&gt;
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; FunctionForSuffix = &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) ([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, &lt;span style=&quot;color: #ffff00;&quot;&gt;error&lt;/span&gt;){
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.gz&quot;&lt;/span&gt;: GzipFileList, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar&quot;&lt;/span&gt;: TarFileList, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar.gz&quot;&lt;/span&gt;: TarFileList, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tgz&quot;&lt;/span&gt;: TarFileList, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.zip&quot;&lt;/span&gt;: ZipFileList}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;ArchiveFileListMap&lt;/span&gt;(file &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) ([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, &lt;span style=&quot;color: #ffff00;&quot;&gt;error&lt;/span&gt;) {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; function, ok := FunctionForSuffix[&lt;span style=&quot;color: #00fa9a;&quot;&gt;Suffix&lt;/span&gt;(file)]; ok {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;function&lt;/span&gt;(file)
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;nil&lt;/span&gt;, errors.&lt;span style=&quot;color: #00fa9a;&quot;&gt;New&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;unrecognized archive&quot;&lt;/span&gt;)
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
这个函数使用了映射，键是字符串（文件名后缀），值是签名为func(string) ([]string, error)的函数。
&lt;/p&gt;

&lt;p&gt;
这个函数使用[]索引操作符根据给定的前缀从FunctionForSuffix结构里得到对应的函数，如果这个前缀存在则ok的值为true，否则为false。如果存在匹配的函数，执行这个函数并将文件名作为参数传递给它，返回它的结果。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-5-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-5-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.5.2&lt;/span&gt; 动态函数的创建&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-5-2&quot;&gt;
&lt;p&gt;
在运行时动态地选择函数的另一个场景便是，当我们有两个或者更多的函数实现了相同的功能时，比如使用了不同的算法等，我们不不希望在程序编译时静态绑定到其中一个函数。
&lt;/p&gt;

&lt;p&gt;
举个例子了，如果我们使用一个7位的ASCII字符，我们可以写一个更加简单的IsPalindrome()函数，而在运行进动态地创建一个我们所需要的版本。
&lt;/p&gt;

&lt;p&gt;
一种做法就是声明一个和这个函数签名相同的包级别的变量，然后创建一个appropriate()函数和一个init()函数。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; IsPalindrome &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20445;&amp;#23384;&amp;#21040;&amp;#20989;&amp;#25968;&amp;#30340;&amp;#24341;&amp;#29992;&lt;/span&gt;
&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;init&lt;/span&gt;() {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(os.Args) &amp;gt; 1 &amp;amp;&amp;amp; (os.Args[1] == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;-a&quot;&lt;/span&gt; || os.Args[1] == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;--ascii&quot;&lt;/span&gt;) {
                os.Args = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(os.Args[:1], os.Args[2:]...) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#21435;&amp;#25481;&amp;#21442;&amp;#25968;&lt;/span&gt;
                IsPalindrome = &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(s &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; {          &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#31616;&amp;#21333;&amp;#30340;ASCII&amp;#29256;&amp;#26412;&lt;/span&gt;
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(s) &amp;lt;= 1 {
                                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;true&lt;/span&gt;
                        }
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; s[0] != s[&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(s)-1] {
                                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;false&lt;/span&gt;
                        }
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;IsPalindrome&lt;/span&gt;(s[1 : &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(s)-1])
                }
        } &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; {
                IsPalindrome = &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(s &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; { &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;UTF8&amp;#29256;&amp;#26412;&lt;/span&gt;
                        &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;...&amp;#21516;&amp;#21069;...&lt;/span&gt;
                }
        }
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
我们根据命令行选项来决定IsPalindrome()的实现方式。如果指定了&quot;-a&quot; 或 &quot;&amp;#x2013;ascii&quot;参数，我们将它从os.Args切片里移除，然后创建一个作用于ASCII码的IsPalindrome()函数。如果ASCII选项没有出现，我们就创建一个和之前一样的函数，既能处理ASCII编码的字符串也能处理UTF8编码的字符串。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-6&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-6&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.6&lt;/span&gt; 高阶函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-6&quot;&gt;
&lt;p&gt;
所谓高阶函数就是将一个或多个其他函数作为自己的参数，并在函数体里调用它们。
&lt;/p&gt;

&lt;p&gt;
一个最简单的高阶函数：
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;SliceIndex&lt;/span&gt;(limit &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, preficate &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := 0; i &amp;lt; limit; i++ {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;preficate&lt;/span&gt;(i) {
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; i
                }
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; -1
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
这个函数返回preficate()为真时的索引值， 所以这个函数能做Index()、IndexReflect()、IntSliceIndex()的所有工作。
&lt;/p&gt;

&lt;p&gt;
下面是函数调用的4个样例和它们输出的结果。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        xs := []&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{2, 4, 5, 8}
        ys := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;K&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;}

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(
                &lt;span style=&quot;color: #00fa9a;&quot;&gt;SliceIndex&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(xs), &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; { &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; xs[i] == 5 }),
                &lt;span style=&quot;color: #00fa9a;&quot;&gt;SliceIndex&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(xs), &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; { &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; xs[i] == 6 }),
                &lt;span style=&quot;color: #00fa9a;&quot;&gt;SliceIndex&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(ys), &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; { &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; ys[i] == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Z&quot;&lt;/span&gt; }),
                &lt;span style=&quot;color: #00fa9a;&quot;&gt;SliceIndex&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(ys), &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; { &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; ys[i] == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt; }))
}
&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#65306;
2 -1 -1 3
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
传给SliceIndex()函数的第二个参数的匿名函数是一个闭包，所以它们引用的xs和ys必须和这个函数被创建的地方在同一作用域。实际上，SliceIndex()就是一个能直接处理切片的通用函数。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;纯记忆函数&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
所谓纯函数就是对同一组输入总是产生相同的结果，不存在任何副作用。如果一个纯函数执行时开销很大而且频繁地使用相同的参数进行调用，我们可以使用记忆功能来降低处理的开销。记忆技术就是保存计算的结果，当执行下一个相同的计算时，我们能返回保存的结果而不是重复执行一次计算过程。
&lt;/p&gt;

&lt;p&gt;
例子1：使用递归的具有记忆功能的斐波纳契函数。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;memoizeFunction&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, ...&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{}

&lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; Fibonacci memoizeFunction

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;init&lt;/span&gt;() {
        Fibonacci = &lt;span style=&quot;color: #00fa9a;&quot;&gt;Memoize&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(x &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, xs ...&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{} {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; x &amp;lt; 2 {
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; x
                }
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;Fibonacci&lt;/span&gt;(x-1).(&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) + &lt;span style=&quot;color: #00fa9a;&quot;&gt;Fibonacci&lt;/span&gt;(x-2).(&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;)
        })
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
Memoize()函数（下文讲到）可以记忆任何传入至少一个int参数并返回一个interface{}的函数。在init()函数里，我们创建了一个计算斐波纳契数列的匿名函数，并立即将它传给Memoize()函数。相应地，Memoize()函数返回一个memoizeFunction类型的函数，然后赋值给Fibonacci变量。
&lt;/p&gt;

&lt;p&gt;
在这个特定例子里，我们只需传一个参数给Fibonacci函数，所以我们可以忽略所有其他传入的整数（即忽略xs，在这个例子里它应该是一个空的切片）。还有，当我们将递归的结果汇总的时候，我们必须使用非检查类型断言将返回值从interface{}类型转换成int类型。
&lt;/p&gt;

&lt;p&gt;
现在我们可以像其他函数那样使用Fibonacci()，而且得益于记忆功能，它不会重复执行相同的计算过程。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;Memoize&lt;/span&gt;(function &lt;span style=&quot;color: #ffff00;&quot;&gt;memoizeFunction&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;memoizeFunction&lt;/span&gt; {
        cache := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{})
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(x &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, xs ...&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{} {
                key := fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Sprint&lt;/span&gt;(x)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; _, i := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; xs {
                        key += fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Sprintf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;, %d&quot;&lt;/span&gt;, i)
                }
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; value, found := cache[key]; found {
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; value
                }
                value := &lt;span style=&quot;color: #00fa9a;&quot;&gt;function&lt;/span&gt;(x, xs...)
                cache[key] = value
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; value
        }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
记忆功能对那些开销大的纯函数而言是非常有用的。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 24 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/24/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/24/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（十三）——过程式编程之defer、panic和recover</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. defer、panic和recover&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. defer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. panic和recover&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; defer、panic和recover&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; defer&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
defer语句用于延迟一个函数、方法或当前所创建的匿名函数的执行，它会在外围函数或方法返回之前但其返回值（如果有的话）计算之后执行。这样就有可能在一个被延迟执行的函数内部修改函数的命名返回值。如果一个函数或方法有多个defer语句，它们会以LIFO(后进先出)的顺序执行。
&lt;/p&gt;

&lt;p&gt;
defer语句最常见的用法是，保证使用完一个文件后将其成功关闭，或将一个不再使用的通道关闭，或者捕获异常。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; file *os.File
&lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; err error
&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; file, err = os.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Open&lt;/span&gt;(filename); err != &lt;span style=&quot;color: #fa8072;&quot;&gt;nil&lt;/span&gt; {
    log.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;failed to open the file&quot;&lt;/span&gt;, err)
    &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt;
}
&lt;span style=&quot;color: #00ffff;&quot;&gt;defer&lt;/span&gt; file.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Close&lt;/span&gt;()
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
文件一打开，就用defer来执行关闭。
&lt;/p&gt;

&lt;p&gt;
再来一个例子,因为defer存在，因此for循环以后进先出的顺序来输出i：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := 0; i &amp;lt; 3; i++ {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;defer&lt;/span&gt; fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(i)
        }
}
&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
2
1
0
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; panic和recover&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
内置的panic和recover函数是Go语言提供的一套异常处理机制。
&lt;/p&gt;

&lt;p&gt;
Go语言将错误和异常两者区分对待。
&lt;/p&gt;

&lt;p&gt;
处理错误的惯用法是将错误以函数或方法最后一个返回值的形式将其返回，并在调用它的时候检查返回的错误值。
&lt;/p&gt;

&lt;p&gt;
处理异常，我们可以调用内置的panic()函数，该函数可以传入任何想要的值（例如一个字符串用于解释为什么那些不变的东西被破坏了）。当内置的panic()函数被调用时，外围函数或方法的执行会立即中止。然而如果其中有个延迟执行的函数或方法包含一个对内置的recover()函数的调用，该异常则不会立即终止。这样我们就可以以任何我们需要的方式来响应异常。你可以忽略异常，也可先完成必要的清理工作，然后手动调用panic()函数来让该异常继续。但是通用的方案是，创建一个error值，并将其设置成包含了recover()调用的函数的返回值（或返回值之一），这样就可以将一个异常（即一个panic()）转换成错误（即一个error）。
&lt;/p&gt;

&lt;p&gt;
绝大多数情况下，Go语言标准库使用error而非异常。对于自定义的函数，一般不使用panic()，如果要使用，也要避免异常离开这个自定义包边界，可以通过使用recover()函数来捕捉异常并返回一个相应的错误值，就像标准库中所做的那样。
&lt;/p&gt;

&lt;p&gt;
什么时候应该允许异常终止程序，什么时候又应该使用recover()来捕捉异常？一般来说，如果程序中有逻辑错误，我们希望程序马上崩溃，以便我们可以发现并修改。但一旦程序部署好了，我们就不想让程序崩溃。对于那些只需通过执行程序就能捕捉的问题，我们应该使用panic()，或者能发生异常的函数（比如regexp.MustCompile()）。对于任何特殊情况下可能运行也可能不运行的函数或方法，如果调用了panic()函数或调用了可发生异常的函数或方法，我们应该使用recover()函数来保证将异常转换成错误。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;ConvertInt64ToInt&lt;/span&gt;(x &lt;span style=&quot;color: #ffff00;&quot;&gt;int64&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; math.MinInt32 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt;= math.MaxInt32 {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;int&lt;/span&gt;(x)
        }
        &lt;span style=&quot;color: #b0c4de;&quot;&gt;panic&lt;/span&gt;(fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Sprintf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%d is out of the int32 range&quot;&lt;/span&gt;, x))
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
该函数安全地将一个int64类型的值转换成一个int类型的值，如果转换产生的结果非法，则报告发生异常。
如果其他函数调用了这个函数，而这个函数又发生了异常，那么就会导致程序终止。在这种情况下，我们可以使用recover()来保证产生的异常不会传递出去，即不会因一个函数产生异常而导致整个程序崩溃。底下是一个包装函数，其功能是，如果转换成功，则返回一个int类型的值和一个nil，如果失败则返回一个int值和一个非空的错误值。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;IntFromInt64&lt;/span&gt;(x &lt;span style=&quot;color: #ffff00;&quot;&gt;int64&lt;/span&gt;) (i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;, err &lt;span style=&quot;color: #ffff00;&quot;&gt;error&lt;/span&gt;) {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;defer&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;() {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; e := &lt;span style=&quot;color: #b0c4de;&quot;&gt;recover&lt;/span&gt;(); e != &lt;span style=&quot;color: #fa8072;&quot;&gt;nil&lt;/span&gt; {
                        err = fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Errorf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%v&quot;&lt;/span&gt;, e)
                }
        }()
        i = &lt;span style=&quot;color: #00fa9a;&quot;&gt;ConvertInt64ToInt&lt;/span&gt;(x)
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; i, &lt;span style=&quot;color: #fa8072;&quot;&gt;nil&lt;/span&gt;
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 16 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/16/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8Bdefer%E3%80%81panic%E5%92%8Crecover.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/16/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8Bdefer%E3%80%81panic%E5%92%8Crecover.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（十二）——过程式编程之通信和并发语句</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 通信和并发语句&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. goroutine的创建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. goroutine之间的通信&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 通道的创建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. select语句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 通信和并发语句&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
本章简要介绍Go语言通信和并发的基本语法，详细的内容将在第7章涉及。
&lt;/p&gt;

&lt;p&gt;
goroutine是程序中与其他goroutine完全相互独立而并发执行的函数或方法调用。每一个Go程序至少有一个goroutine，即用来执行main函数的主goroutine。
&lt;/p&gt;

&lt;p&gt;
goroutine非常像轻量的线程或协程，可以大批量创建，所有的goroutine共享相同的地址空间，同时提供锁原语来保证数据能安全地跨goroutine共享。
&lt;/p&gt;

&lt;p&gt;
Go语言推荐使用通信而非共享数据来进行并发编程。通道是一个双向或单向的通信管道，可用于在两个或多个goroutine之间通信（接收或发送）数据。
&lt;/p&gt;

&lt;p&gt;
在goroutine和通道之间，Go语言提供了一种轻量级、可扩展的并发方式，该方式不需要共享内存，因此也不需要锁。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; goroutine的创建&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;go&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;function&lt;/span&gt;(arguments)
&lt;span style=&quot;color: #00ffff;&quot;&gt;go&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(&lt;span style=&quot;color: #ffff00;&quot;&gt;parameters&lt;/span&gt;) {block} (arguments)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
goroutine的创建非常简单，只需要使用go关键字即可。我们要么调用一个函数，要么调用一个临时创建的匿名函数。被调用的函数的执行会立即进行，但它是在另一个goroutine上执行，并且当前goroutine的执行（即包含该go语句的goroutine）会从下一条语句中立即恢复。因此执行一个go语句之后，当前程序中至少有两个goroutine在运行，其中包括原始的goroutine和新创建的goroutine。这和进程与线程的创建相似。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; goroutine之间的通信&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;channel &amp;lt;- value         &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#38459;&amp;#22622;&amp;#21457;&amp;#36865;&lt;/span&gt;
&amp;lt;-channel                &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#25509;&amp;#25910;&amp;#24182;&amp;#23558;&amp;#20854;&amp;#20002;&amp;#24323;&lt;/span&gt;
x := &amp;lt;-channel           &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#25509;&amp;#25910;&amp;#24182;&amp;#23558;&amp;#20854;&amp;#20445;&amp;#23384;&lt;/span&gt;
x, ok := &amp;lt;-channel       &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#21151;&amp;#33021;&amp;#21516;&amp;#19978;&amp;#19968;&amp;#26465;&amp;#65292;&amp;#21516;&amp;#26102;&amp;#26816;&amp;#26597;&amp;#36890;&amp;#36947;&amp;#26159;&amp;#21542;&amp;#24050;&amp;#20851;&amp;#38381;&amp;#25110;&amp;#26159;&amp;#21542;&amp;#20026;&amp;#31354;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
非阻塞发送可以使用select语句，或使用带缓冲的通道。
&lt;/p&gt;

&lt;p&gt;
通道使用内置make()函数来创建。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 通道的创建&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt; (&lt;span style=&quot;color: #00ffff;&quot;&gt;chan&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;)                   &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#21516;&amp;#27493;&amp;#36890;&amp;#36947;&amp;#65292;&amp;#38459;&amp;#22622;&amp;#24335;&lt;/span&gt;
&lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt; (&lt;span style=&quot;color: #00ffff;&quot;&gt;chan&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;, capacity)         &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#24322;&amp;#27493;&amp;#36890;&amp;#36947;&amp;#65292;&amp;#32531;&amp;#20914;&amp;#24335;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
如果没有声明缓冲区容量，那么该通道就是同步的，因此会阻塞直到发送者准备好发送和接收者准备好接收。如果设定了缓冲区容量，那么通道就是异步的，只要缓冲区还有未使用的空间用于发送数据，或还有未输出的数据，那么其通信就会无阻塞地进行。
&lt;/p&gt;

&lt;p&gt;
通道默认是双向的，当然，也可设定为单向（在第7章介绍）。
例子：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        counterA := &lt;span style=&quot;color: #00fa9a;&quot;&gt;createCounter&lt;/span&gt;(2)   &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;counterA&amp;#26159;chan int&amp;#31867;&amp;#22411;&lt;/span&gt;
        counterB := &lt;span style=&quot;color: #00fa9a;&quot;&gt;createCounter&lt;/span&gt;(102) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;counterB&amp;#26159;chan int&amp;#31867;&amp;#22411;&lt;/span&gt;
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := 0; i &amp;lt; 5; i++ {
                a := &amp;lt;-counterA
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;(A&amp;#8594;%d, B&amp;#8594;%d)&quot;&lt;/span&gt;, a, &amp;lt;-counterB)
        }
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;()
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;createCounter&lt;/span&gt;(start &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #00ffff;&quot;&gt;chan&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; {
        next := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;chan&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;)

        &lt;span style=&quot;color: #00ffff;&quot;&gt;go&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; {
                        next &amp;lt;- i
                        i++
                }
        }(start)
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; next
}

&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
(A&amp;#8594;2, B&amp;#8594;102)(A&amp;#8594;3, B&amp;#8594;103)(A&amp;#8594;4, B&amp;#8594;104)(A&amp;#8594;5, B&amp;#8594;105)(A&amp;#8594;6, B&amp;#8594;106)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; select语句&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
select语法如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;select&lt;/span&gt; {
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; sendOrReceive1: block1
...
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; sendOrReceiveN: blockN
&lt;span style=&quot;color: #00ffff;&quot;&gt;default&lt;/span&gt;: blockD
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收语句，如果其中任一语句可执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。如果没有任意一条语句可以执行（即所有通道都被阻塞），那么有两种可能的情况。如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复，但是如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以继续下去。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;math/rand&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        channels := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #00ffff;&quot;&gt;chan&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt;, 6)
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; channels {
                channels[i] = &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;chan&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt;)
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;go&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;() {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; {
                        channels[rand.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Intn&lt;/span&gt;(6)] &amp;lt;- &lt;span style=&quot;color: #fa8072;&quot;&gt;true&lt;/span&gt;
                }
        }()

        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := 0; i &amp;lt; 36; i++ {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; x int
                &lt;span style=&quot;color: #00ffff;&quot;&gt;select&lt;/span&gt; {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &amp;lt;-channels[0]:
                        x = 1
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &amp;lt;-channels[1]:
                        x = 2
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &amp;lt;-channels[2]:
                        x = 3
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &amp;lt;-channels[3]:
                        x = 4
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &amp;lt;-channels[4]:
                        x = 5
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &amp;lt;-channels[5]:
                        x = 6

                }
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%d &quot;&lt;/span&gt;, x)
        }
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;()

}

&amp;#38543;&amp;#26426;&amp;#36755;&amp;#20986;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
6 4 6 6 2 1 2 3 5 1 3 2 1 6 5 3 4 6 6 3 6 1 3 5 4 2 2 5 1 4 2 1 6 6 4 3
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
在上面代码中，首先创建了6个用于发送和接收布尔数据的通道。然后创建了一个gorotine，其中有一个无限循环语句，在循环中每次迭代都随机选择了一个通道来发送一个true值。当然，该gorotine会立即阻塞，因为这些通道不带缓冲且我们也没有从这些通道接收数据。
&lt;/p&gt;

&lt;p&gt;
接下来的代码，我们使用6个通道来模拟一个公平骰子的滚动。其中的select语句等待通道发送数据，由于没有default语句，该select语句会阻塞。一旦有一个或更多个通道准备好了发送数据，那么程序会以伪随机的形式选择一个case语句来执行。由于该select语句在一个普通for循环内部，它会执行固定数量的次数。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 15 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/15/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E5%B9%B6%E5%8F%91%E8%AF%AD%E5%8F%A5.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/15/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E5%B9%B6%E5%8F%91%E8%AF%AD%E5%8F%A5.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（十一）——过程式编程之循环语句</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. for循环语句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; for循环语句&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
Go语言没有while和do&amp;#x2026;while循环语句，只提供for循环语句。但是Go语言的for比c/c++的for语句更丰富、更灵活。
&lt;/p&gt;

&lt;p&gt;
Go语言的for有两种类型：一是无格式的for语句，一是for&amp;#x2026;range语句。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; { &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#26080;&amp;#38480;&amp;#24490;&amp;#29615;&lt;/span&gt;
    block
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; booleanExpression {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#30456;&amp;#24403;&amp;#20110;while&amp;#24490;&amp;#29615;&lt;/span&gt;
    block
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; optionalPreStatement; booleanExpress; optionalPostStatement { &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#9312;&lt;/span&gt;
    block
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; index, char := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; aString {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#22320;&amp;#36845;&amp;#20195;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#9313;&lt;/span&gt;
    block
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; index := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; aString {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#22320;&amp;#36845;&amp;#20195;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#9314;&lt;/span&gt;
    block  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;char, size := utf8.DecodeRuneInString(aString[index:])&lt;/span&gt;
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; index, item := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; anArrayOrSlice {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#25968;&amp;#32452;&amp;#25110;&amp;#20999;&amp;#29255;&amp;#36845;&amp;#20195;&amp;#9315;&lt;/span&gt;
    block
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; index := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; anArrayOrSlice {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#25968;&amp;#32452;&amp;#25110;&amp;#20999;&amp;#29255;&amp;#36845;&amp;#20195;&amp;#9316;&lt;/span&gt;
    block  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;item := anArrayOrSlice[index]&lt;/span&gt;
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; key, value := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; aMap {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#26144;&amp;#23556;&amp;#36845;&amp;#20195;&amp;#9317;&lt;/span&gt;
    block
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; key := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; aMap {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#26144;&amp;#23556;&amp;#36845;&amp;#20195;&amp;#9318;&lt;/span&gt;
    block &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;value := aMap[key]&lt;/span&gt;
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; item := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; aChannel { &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#36890;&amp;#36947;&amp;#36845;&amp;#20195;&lt;/span&gt;
    block
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;for循环中的花括号与if、switch一样是必须的，分号只在可选的前置或后置声明语句都存在的时候才需要，比如①。两个声明必须是简短的。如果变量是在一个可选的声明语句中创建，或用来保存一个range子句中产生的值，那么它们的作用域是从声明处到for语句结束。
&lt;/li&gt;
&lt;li&gt;字符串迭代可用②或③，通常②比③ 更方便。
&lt;/li&gt;
&lt;li&gt;对于非空切片或索引而言，④和⑤依不同需要同样方便。在Go语言中，更多使用for&amp;#x2026;range而较少用①的循环。
&lt;/li&gt;
&lt;li&gt;映射的迭代使用⑥或⑦，如需要有序的映射，就使用⑦。
&lt;/li&gt;
&lt;li&gt;②至⑦如作用于一个空的字符串、数组、切片或映射，那么for循环就什么也不做。控制流程从下一条语句继续。
&lt;/li&gt;
&lt;li&gt;一个for循环可以随时使用break语句来终止，这样控制权将传送给for循环语句的一一条语句。如果break语句声明了一个标签（见下面的例子），那么控制权就会进入包含该标签的最内层for、switch或者select语句中。也可通过continue来使得语句的控制权回到for循环的条件或范围子句，以进行新一次迭代。
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;b&gt;例子：&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
假设有一个二维切片，其类型为[][]int，想要从中搜索是否包含某个特定的值。以下有两种方法。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;found := &lt;span style=&quot;color: #fa8072;&quot;&gt;false&lt;/span&gt;
&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; row := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; table {
    &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; column := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; table[row] {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; table[row][column] == x {
            found = &lt;span style=&quot;color: #fa8072;&quot;&gt;true&lt;/span&gt;
            &lt;span style=&quot;color: #00ffff;&quot;&gt;break&lt;/span&gt;
        }
    }
    &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; found {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;break&lt;/span&gt;
    }
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;found := &lt;span style=&quot;color: #fa8072;&quot;&gt;false&lt;/span&gt;
&lt;span style=&quot;color: #fa8072;&quot;&gt;FOUND&lt;/span&gt;:
&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; row := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; table {
    &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; column := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; table[row] {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; table[row][column] == x {
            found = &lt;span style=&quot;color: #fa8072;&quot;&gt;true&lt;/span&gt;
            &lt;span style=&quot;color: #00ffff;&quot;&gt;break&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;FOUND&lt;/span&gt;
        }
    }
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
第一个程序片段通过两个break跳出两层for循环。第二个程序片段通过break FOUND标签直接跳出两层for循环。
&lt;/p&gt;

&lt;p&gt;
标签是一个后面带冒号的标识符。可以用于for、switch以及select语句。break和continue语句都可以声明标签，并且都可用于for循环里面。同时也可以在switch和select语句里面使用break语句。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 13 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/13/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/13/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（十）——过程式编程之分支</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第5章 过程式编程——分支&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. if语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. switch语句&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-1&quot;&gt;1.2.1. 表达式开关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2&quot;&gt;1.2.2. 类型开关&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第5章 过程式编程——分支&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
Go语言提供了3种分支语句，即if、switch和select。select将在本章末尾介绍。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; if语句&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
Go语言if语句语法如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; optionalStatement1; booleanExpression1 {
    block1
} &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; optionalStatement2; booleanExpression2 {
    block2
} &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; {
    block3
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;if后面的条件判断语句不需要用括号包裹起来。
&lt;/li&gt;
&lt;li&gt;大（花）括号的位置是规定的。
&lt;/li&gt;
&lt;li&gt;条件判断语句里允许声明一个变量 ，这个变量的作用域只能在该条件逻辑块内。
&lt;/li&gt;
&lt;li&gt;布尔表达式必须是bool类型。Go不支持自动转换非布尔值，因此必须使用比较操作符。例如，if i == 0。
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
以下两个示例为if的惯用法。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;在if内部声明一个临时变量，而不是在if外部
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#24815;(&amp;#32463;&amp;#20856;)&amp;#29992;&amp;#27861;&lt;/span&gt;
&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; a := &lt;span style=&quot;color: #00fa9a;&quot;&gt;compute&lt;/span&gt;(); a &amp;lt; 0 {
    fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;(%d)\n&quot;&lt;/span&gt;, -a)
} &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; {
    fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(a)
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#21872;&amp;#21990;&amp;#29992;&amp;#27861;&lt;/span&gt;
a := &lt;span style=&quot;color: #00fa9a;&quot;&gt;compute&lt;/span&gt;()
&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; a &amp;lt; 0 {
    fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;(%d)\n&quot;&lt;/span&gt;, a)
} &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; {
    fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(a)
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;最后一个return不需要使用else
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;ArchiveFileList&lt;/span&gt; (file &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) ([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; error) {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; suffix := &lt;span style=&quot;color: #00fa9a;&quot;&gt;Suffix&lt;/span&gt;(file); suffix == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.gz&quot;&lt;/span&gt; {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;GzipFileList&lt;/span&gt;(file)
        } &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; suffix == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar&quot;&lt;/span&gt; || suffix == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar.gz&quot;&lt;/span&gt; || suffix == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tgz&quot;&lt;/span&gt; {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;TarFileList&lt;/span&gt;(file)
        } &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; suffix == &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.zip&quot;&lt;/span&gt; {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;ZipFileList&lt;/span&gt;(file)
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;nil&lt;/span&gt;, errors.&lt;span style=&quot;color: #00fa9a;&quot;&gt;New&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;unrecognized archive&quot;&lt;/span&gt;)
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; switch语句&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
Go语言有两种类型的switch语句：表达式开关(expression switch)和类型开关(type switch)。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-2-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.2.1&lt;/span&gt; 表达式开关&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-2-1&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;switch&lt;/span&gt; optionalStatement; optionalExpression {
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; expressionList1: block1
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; expressionList2: block2
...
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; expressionListN: blockN
&lt;span style=&quot;color: #00ffff;&quot;&gt;default&lt;/span&gt;: blockD
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
注意：
&lt;/p&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;如果有可选的声明语句，那么中间的分号是必须的。无论后面可选的表达式是否出现。
&lt;/li&gt;
&lt;li&gt;如果switch未包含表达式语句，则默认为true
&lt;/li&gt;
&lt;li&gt;case默认不会往下贯穿，所以不需要在结尾使用break语句。如果需要往下贯穿，需使用fallthrough语句。
&lt;/li&gt;
&lt;li&gt;default语句可选，如有，一般放在最后。
&lt;/li&gt;
&lt;li&gt;如case或default后带break或return，则运行到break或return时会提前结束代码块的执行。
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;switch&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;Suffix&lt;/span&gt;(file) {
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.gz&quot;&lt;/span&gt;:
    &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;GzipFileList&lt;/span&gt;(file)
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tar.gz&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.tgz&quot;&lt;/span&gt;:
    &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;TarFileList&lt;/span&gt;(file)
&lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;.zip&quot;&lt;/span&gt;:
    &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;ZipFileList&lt;/span&gt;(file)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-2-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.2.2&lt;/span&gt; 类型开关&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-2-2&quot;&gt;
&lt;p&gt;
在笔记（九）的最后一小节提到类型断言，我们也可以使用switch来进行类型判断,当需要判断的类型特别多时，用switch更清晰简洁。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;classifier&lt;/span&gt;(items... &lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{}) {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i, x := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; items {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;switch&lt;/span&gt; x.(&lt;span style=&quot;color: #00ffff;&quot;&gt;type&lt;/span&gt;) {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; bool:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d is a bool\n&quot;&lt;/span&gt;, i)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; float64:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d is a float64\n&quot;&lt;/span&gt;, i)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; int, int8, int16, int32, int64:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d is a int\n&quot;&lt;/span&gt;, i)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; uint, uint8, uint16, uint32, uint64:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d is a unsigned int\n&quot;&lt;/span&gt;, i)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; &lt;span style=&quot;color: #fa8072;&quot;&gt;nil&lt;/span&gt;:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d is nil\n&quot;&lt;/span&gt;, i)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;case&lt;/span&gt; string:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d is a string\n&quot;&lt;/span&gt;, i)
                &lt;span style=&quot;color: #00ffff;&quot;&gt;default&lt;/span&gt;:
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;param #%d&#39;s type is unknow\n&quot;&lt;/span&gt;, i)
                }
        }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 11 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/11/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%88%86%E6%94%AF.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/11/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%88%86%E6%94%AF.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>firefox使用stylish扩展显示weibo.com等网站的字体图标</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 存在的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. 解决办法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 存在的问题&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
firefox中可以自定义页面显示字体。比如使用微软雅黑等漂亮的字体。但是在taobao.com、weibo.com和github.com等网站上有些图标是利用字体来显示的，因此一旦去掉“允许页面选择字体”选项时，上述网站的一些以字体来显示的图标就无法显示，甚至乱码。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; 解决办法&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;在firefox附加组件中安装stylish扩展。重启后，在“附加组件”-&amp;gt;“用户样式”-&amp;gt;&quot;stylish&quot;中选择新建样式，填入以下内容。保存，重启。
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-style&quot;&gt;@namespace url(http://www.w3.org/1999/xhtml);
@-moz-document regexp(&quot;((?!github.com|itellyou.cn|400gb.com|mozilla.org|alipay.com|weibo.com|taobao.com|wallbase.cc).)*&quot;){
 * {font-family:微软雅黑 !important;}
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;在firefox“选项”-&amp;gt;“内容”-&amp;gt;&quot;高级&quot;中把&quot;允许页面选择显示字体而无需使用上面的设置&quot;打上勾就行了。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/firefox/2014/11/10/firefox%E4%BD%BF%E7%94%A8stylish%E6%89%A9%E5%B1%95%E6%98%BE%E7%A4%BAweibo.com%E7%AD%89%E7%BD%91%E7%AB%99%E7%9A%84%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87.html</link>
        <guid isPermaLink="true">http://xep007.github.io/firefox/2014/11/10/firefox%E4%BD%BF%E7%94%A8stylish%E6%89%A9%E5%B1%95%E6%98%BE%E7%A4%BAweibo.com%E7%AD%89%E7%BD%91%E7%AB%99%E7%9A%84%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87.html</guid>
        
        <category>firefox</category>
        
        
        <category>firefox</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（九）——过程式编程之语句基础</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第5章 过程式编程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. 语句基础&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-1&quot;&gt;1.1.1. 类型转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-2&quot;&gt;1.1.2. 类型断言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第5章 过程式编程&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
Go语言可以用于写纯过程式程序，可用于写纯面向对象程序，也可用于写过程式和面向对象式相结合的程序。过程式编程很重要，因为它是并发编程和面向对象编程的基础。
&lt;/p&gt;

&lt;p&gt;
前几章描述并阐明了Go语言内置的数据类型，本章将详细地讲解Go语言的表达式语句和控制结构，同时详细是讲解创建和使用自定义的函数。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; 语句基础&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
编写Go语言程序时，不必显式地使用分号（;）来作为上下文语句的分隔结束符。在编译时，Go语言能智能地在该加分号的地方加上分号。但是有两个地方必须使用分号（;），一是当我们需要在一行中放入多条语句时，一是在使用原始的for循环时。
&lt;/p&gt;

&lt;table border=&quot;2&quot; cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; rules=&quot;groups&quot; frame=&quot;hsides&quot;&gt;
&lt;caption class=&quot;t-above&quot;&gt;&lt;span class=&quot;table-number&quot;&gt;Table 1:&lt;/span&gt; Go语言内置函数&lt;/caption&gt;

&lt;colgroup&gt;
&lt;col  class=&quot;left&quot; /&gt;

&lt;col  class=&quot;left&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;语法&lt;/th&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;含义/结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;append(s, &amp;#x2026;)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;如果切片s的容量足够，则将函数末尾的项添加进给定的切片中;否则新建一个切片，&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;其内容为原始切片的项和函数末尾传入的项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;cap(x)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;切片x的容量、通道x的缓存容量、数组x（或所指向数组）的长度。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;close(ch)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;关闭通道ch（但用于只接收信息的通道是非法的）。不能再往通道中发送数据。数据还可以从关闭的通道中接收&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;（例如，任何已发送但未接收的值），并且如果通道中没有值了，接收端得到的将是通道类型的零值。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;complex(r, i)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;一个complex128复数，其实部r和虚部i给定，并且都为float64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;copy(dst, src)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;将src切片中的项复制（可能是重叠）到dst切片中，如果空间不够则截断;或者将字符串s复制到[]byte类型的b中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;copy(b, s)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;delete(m, k)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从映射m中删除键为k的项，如果键为空则什么也不做&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;imag(cx)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;作为float64类型的complex128类型数据的虚部&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;len(x)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;切片x的长度、通道x的缓冲区中排队的项的数量、数组（或所指向数组）的长度、一个映射x中项的个数、字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;x中的字节的个数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;make(T)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;一个切片、映射或通道类型T的引用。如果给定n，那它就是该切片的长度和容量，或者提示一个映射需要多少项，&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;make(T, n)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;或者一个缓冲区的大小。对于切片而言，n和m可用于声明长度和容量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;make(T,n, m)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;new(T)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;一个指向类型T的值指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;panic(x)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;抛出一个运行时异常，其值为x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;real(cx)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;类型为complex128的cx值的实部，是一个float64类型值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;recover()&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;捕获一个运行时异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
Go语言支持++（递增）和&amp;#x2013;（递减）操作符。它们都是后置操作符，必须跟在一个操作数后面，并且没有返回值。因此，这两个操作符不能用于表达式。举例，x++不是表达式，而是语句，*p++是(*p)++而不是*(p++)。
&lt;/p&gt;

&lt;p&gt;
赋值通过使用=赋值操作符来完成。变量可以使用=和一个var连接起来创建和赋值。如：
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
var a = 5
&lt;/pre&gt;
&lt;p&gt;
此赋值语句和 
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
a := 5
&lt;/pre&gt;
&lt;p&gt;
所达到的目的一样（全局变量不能用:=操作符，只能用var）。
&lt;/p&gt;

&lt;p&gt;
Go语言支持多重赋值，如: 
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
a, b = 3, 4
&lt;/pre&gt;
&lt;p&gt;
多重赋值使得交换两个变量的值变得非常方便，它不需要引入第三个变量。
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
a, b = b, a
&lt;/pre&gt;

&lt;p&gt;
快速声明操作符（:=）用于同时在一个语句中声明和赋值一个变量。多个逗号分隔的变量用法大多数情况下跟=操作符一样，除了必须至少有一个非空变量为新的。如果有一个变量已经存在，它就会直接被赋值，而不会新建一个变量，除非该:=操作符位于作用域的起始处，如if或者for语句中的初始化语句。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;a, b, c := 2, 3, 5
&lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; a:= 7; a &amp;lt; 8; a++ {  &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;a&amp;#26080;&amp;#24847;&amp;#38388;&amp;#35206;&amp;#30422;&amp;#20102;&amp;#22806;&amp;#37096;a&amp;#30340;&amp;#20540;&lt;/span&gt;
    b := 11              &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;b&amp;#26080;&amp;#24847;&amp;#38388;&amp;#35206;&amp;#30422;&amp;#20102;&amp;#22806;&amp;#37096;b&amp;#30340;&amp;#20540;&lt;/span&gt;
    c = 13               &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;c&amp;#20026;&amp;#22806;&amp;#37096;&amp;#30340;c&amp;#20540;&lt;/span&gt;
    fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;inner: a&amp;#8594;%d b&amp;#8594;%d c&amp;#8594;%d\n&quot;&lt;/span&gt;, a, b, c)
}
fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;outer: a&amp;#8594;%d b&amp;#8594;%d c&amp;#8594;%d\n&quot;&lt;/span&gt;, a, b, c)

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&lt;span style=&quot;color: #fa8072;&quot;&gt;inner&lt;/span&gt;: a&amp;#8594;7 b&amp;#8594;11 c&amp;#8594;13
&lt;span style=&quot;color: #fa8072;&quot;&gt;outer&lt;/span&gt;: a&amp;#8594;2 b&amp;#8594;3 c&amp;#8594;13
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
这个代码片段展示了:=操作符是如何创建“影子”变量的。在上面代码中，for循环里面可以对for外部的已定义的变量进行重新定义（赋值）而不造成冲突，我们可以看到，for内部重新定义的变量的作用域只在for内部。
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.1&lt;/span&gt; 类型转换&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-1&quot;&gt;
&lt;p&gt;
Go语言提供了一种在不同但相互兼容的类型之间相互转换的方式，并且这种转换非常有用并且安全。非数值类型之间的转换不会丢失精度。但对于数值类型之间的转换，可能会发生丢失精度或者其他问题。例如，x := uint16(65000),然后使用转换y := int16(x)，由于x走出了int16的范围，y的值会被转换成-536（错误值）。
&lt;/p&gt;

&lt;p&gt;
下面是转换的语法：
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
resultOfType := Type(expression)
&lt;/pre&gt;

&lt;p&gt;
一个字符串可以转换成一个[]byte（其底层为UTF-8的字节）或者一个[]rune（它的Unicode码点），并且[]byte和[]rune都可以转换成一个字符串类型。单个字符是一个rune类型数据（即int32），可以转换成一个单字符的字符串。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-1-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.2&lt;/span&gt; 类型断言&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-2&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;resultOfType, boolean := expression.(&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;)    &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#23433;&amp;#20840;&amp;#31867;&amp;#22411;&amp;#26029;&amp;#35328;&lt;/span&gt;
resultOfType := expression.(&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;)             &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#38750;&amp;#23433;&amp;#20840;&amp;#31867;&amp;#22411;&amp;#26029;&amp;#35328;&amp;#65292;&amp;#22833;&amp;#36133;&amp;#26102;panic()&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
安全类型断言如成功则返回一个值和true，失败则返回目标类型的0值和false。非安全类型断言要么返回一个目标类型的值，要么调用内置的panic()函数抛出一个异常。如未处理异常，则程序将终止。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; i &lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{} = 99
        &lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; s &lt;span style=&quot;color: #00ffff;&quot;&gt;interface&lt;/span&gt;{} = []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;left&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;right&quot;&lt;/span&gt;}
        j := i.(&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;j&amp;#26159;int&amp;#31867;&amp;#22411;&amp;#30340;&amp;#25968;&amp;#25454;&amp;#65288;&amp;#25110;&amp;#32773;&amp;#21457;&amp;#29983;&amp;#20102;&amp;#19968;&amp;#20010;panic()&amp;#65289;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%T&amp;#8594;%d\n&quot;&lt;/span&gt;, j, j)
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; i, ok := i.(&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;); ok {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%T&amp;#8594;%d\n&quot;&lt;/span&gt;, i, j) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;i&amp;#26159;&amp;#19968;&amp;#20010;int&amp;#31867;&amp;#22411;&amp;#30340;&amp;#24433;&amp;#23376;&amp;#21464;&amp;#37327;&lt;/span&gt;
        }
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; s, ok := s.([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;); ok {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%T&amp;#8594;%q\n&quot;&lt;/span&gt;, s, s) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;s&amp;#26159;&amp;#19968;&amp;#20010;[]string&amp;#31867;&amp;#22411;&amp;#30340;&amp;#24433;&amp;#23376;&amp;#21464;&amp;#37327;&lt;/span&gt;
        }
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
int&amp;#8594;99
int&amp;#8594;99
[]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&amp;#8594;&lt;/span&gt;[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;left&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;right&quot;&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/10/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/10/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（八）——集合类型之映射</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. Go语言程序设计读书笔记（八）——集合类型之映射&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. 映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. 创建和填充映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 映射查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. 映射修改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5&quot;&gt;1.5. 键序遍历映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6&quot;&gt;1.6. 映射反转&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; Go语言程序设计读书笔记（八）——集合类型之映射&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; 映射&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
Go语言中的映射(map)是一种内置的数据结构，保存键——值对的无序集合，它的容量只受到机器内在的限制。
&lt;/p&gt;

&lt;p&gt;
在一个映射里所有的键都是唯一的而且必须是支持==和!=操作符的类型，大部分Go语言的基本类型都可以作为映射的键，例如：int、float64、rune、string、可比较的数组和结构体、基于这些类型的自定义类型，以及指针。Go语言的切片和不能用于比较的数组和结构体以及基于这些类型的自定义类型都不能用作键。
&lt;/p&gt;

&lt;p&gt;
指针、引用类型或任何内置类型的值、自定义类型都可用作值，包括映射本身。因此，它可以创建任意复杂的数据结构。
&lt;/p&gt;

&lt;table border=&quot;2&quot; cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; rules=&quot;groups&quot; frame=&quot;hsides&quot;&gt;
&lt;caption class=&quot;t-above&quot;&gt;&lt;span class=&quot;table-number&quot;&gt;Table 1:&lt;/span&gt; 映射的操作&lt;/caption&gt;

&lt;colgroup&gt;
&lt;col  class=&quot;left&quot; /&gt;

&lt;col  class=&quot;left&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;语法&lt;/th&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;含义/结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;m[k] = v&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;用键k来将值v赋值给映射m。如果映射m中的k已存在，则将之前的值丢弃&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;Delete(m, k)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;将键k及其相关的值从映射m中删除。如果k不存在则安全地不执行任何操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;v := m[k]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从映射m中取得键k相对应的值并将其赋值给v。如果k在映射中不存在，则将映射类型的0值赋值给v&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;v, found := m[k]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从映射m中取得键k相对应的值并将其赋值给v,并将found的值赋值为true。如果k在映射中不存在，&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;则将映射类型的0值 赋值给v，并将found的值赋值为false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;len(m)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;返回映射m中的项（“键/值”对） 的数目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
映射属于引用类型，其传递很廉价，其搜索很快，比线性搜索还快100倍左右。
&lt;/p&gt;

&lt;p&gt;
映射里所有键类型必须是相同的，所有值类型必须是相同的，但键和值的类型可以不同。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;映射的创建方式&lt;/b&gt;
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
make (map[KeyType]ValueType, initialCapacity)
make (map[KeyType]ValueType)
map[KeyType]ValueType{}
map[KeyType]ValueType{key1: value1, key2:value2, ..., keyN:valueN}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; 创建和填充映射&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;键为string类型，值为float64类型的映射
&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        massForPlanet := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;float64&lt;/span&gt;) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#19982;map[string]float64{}&amp;#30456;&amp;#21516;&lt;/span&gt;
        massForPlanet[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mercury&quot;&lt;/span&gt;] = 0.06
        massForPlanet[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Venus&quot;&lt;/span&gt;] = 0.82
        massForPlanet[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Earth&quot;&lt;/span&gt;] = 1.00
        massForPlanet[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mars&quot;&lt;/span&gt;] = 0.11

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(massForPlanet)
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[ Mercury:0.06 Venus:0.82 Earth:1 Mars:0.11 ]
&lt;/pre&gt;
&lt;/div&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;键的类型为指针
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;Point&lt;/span&gt; &lt;span style=&quot;color: #00ffff;&quot;&gt;struct&lt;/span&gt;{ x, y, z int }

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; (point &lt;span style=&quot;color: #ffff00;&quot;&gt;Point&lt;/span&gt;) &lt;span style=&quot;color: #00fa9a;&quot;&gt;String&lt;/span&gt;() &lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Sprintf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;(%d, %d, %d)&quot;&lt;/span&gt;, point.x, point.y, point.z)
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {

        triangle := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[*&lt;span style=&quot;color: #ffff00;&quot;&gt;Point&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, 3)
        triangle[&amp;amp;&lt;span style=&quot;color: #ffff00;&quot;&gt;Point&lt;/span&gt;{89, 47, 27}] = &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;a&quot;&lt;/span&gt;
        triangle[&amp;amp;&lt;span style=&quot;color: #ffff00;&quot;&gt;Point&lt;/span&gt;{86, 65, 86}] = &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;b&quot;&lt;/span&gt;
        triangle[&amp;amp;&lt;span style=&quot;color: #ffff00;&quot;&gt;Point&lt;/span&gt;{7, 44, 45}] = &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;c&quot;&lt;/span&gt;

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(triangle)
}
&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[(&lt;span style=&quot;color: #ffff00;&quot;&gt;89&lt;/span&gt;, 47, 27):&lt;span style=&quot;color: #00fa9a;&quot;&gt;a&lt;/span&gt; (86, 65, 86):&lt;span style=&quot;color: #00fa9a;&quot;&gt;b&lt;/span&gt; (7, 44, 45):c]
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
使用指针作为键，意味着我们可以增加两个相同的内容，只要分别创建它们就可以获得不同的地址。但如果我们希望这个映射对任何实际上相同的内容只存储一个的话，我们就存储Point的值而不是指向Point的指针就可以了。即把struct作为键。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 映射查询&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
映射和数组或切片一样可以使用索引操作符[]，但为数组或切片不同的是，映射的键类型不必是int类型。Go语言提供了两种类型的语法用于映射查询，两种方式都使用[]操作符。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        populationForCity := &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt;: 12610000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;:  10620000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;:   12690000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;: 13680000,
        }

        population := populationForCity[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;]
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&#39;s population is &quot;&lt;/span&gt;, population)
        population = populationForCity[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Emerald City&quot;&lt;/span&gt;]
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Emerald City&#39;s population is &quot;&lt;/span&gt;, population)

}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
Mumbai&lt;span style=&quot;color: #ffa500;&quot;&gt;&#39;s population is  12690000&lt;/span&gt;
&lt;span style=&quot;color: #ffa500;&quot;&gt;Emerald City&#39;&lt;/span&gt;s population is  0
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
如果我们查询的键在映射里，就返回它的值。如果键不存在，就会返回一个0值。这就会出现一个问题，0是表示不存在这个键还是它的值就是0。为了避免这种情况，我们可以使用以下另一种查询方法。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        populationForCity := &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt;: 12610000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;:  10620000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;:   12690000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;: 13680000,
        }

        city := &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Emerald&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; population, found := populationForCity[city]; found {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%s&#39;s population is %d\n&quot;&lt;/span&gt;, city, population)
        } &lt;span style=&quot;color: #00ffff;&quot;&gt;else&lt;/span&gt; {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%s&#39;s population data is unavailable\n&quot;&lt;/span&gt;, city)
        }

}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
Emerald&lt;span style=&quot;color: #ffa500;&quot;&gt;&#39;s population data is unavailable&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; 映射修改&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
我们可以往映射里插入或删除一个项（键/值对）。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        populationForCity := &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt;: 12610000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;:  10620000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;:   12690000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;: 13680000,
        }

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(populationForCity), populationForCity)
        &lt;span style=&quot;color: #b0c4de;&quot;&gt;delete&lt;/span&gt;(populationForCity, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#21024;&amp;#38500;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(populationForCity), populationForCity)
        populationForCity[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Emerald&quot;&lt;/span&gt;] = 11620000 &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#25554;&amp;#20837;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#38190;/&amp;#20540;&amp;#23545;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(populationForCity), populationForCity)

}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
4 &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;Istanbul&lt;/span&gt;:12610000 Karachi:10620000 Mumbai:12690000 Shanghai:13680000]
3 &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;Mumbai&lt;/span&gt;:12690000 Istanbul:12610000 Karachi:10620000]
4 &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;Emerald&lt;/span&gt;:11620000 Istanbul:12610000 Karachi:10620000 Mumbai:12690000]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-5&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.5&lt;/span&gt; 键序遍历映射&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-5&quot;&gt;
&lt;p&gt;
按键的顺序遍历映射。映射是无序集合，如果我们想要按顺序输出映射，可以有两种方式，一种是按键顺序输出，一种是按值顺序输出。本节先介绍按键序输出。按键顺序输出的思想是创建一个足够大的切片去保存映射里的所有键，然后对切片排序，遍历切片得到键，再从映射里得到这个键的值。这样就可以实现顺序输出了。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;sort&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        populationForCity := &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt;: 12610000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;:  10620000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;:   12690000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;: 13680000,
        }

        cities := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, 0, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(populationForCity))
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; city := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; populationForCity {
                cities = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(cities, city)
        }

        sort.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Strings&lt;/span&gt;(cities)
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; _, city := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; cities {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%-10s  %8d\n&quot;&lt;/span&gt;, city, populationForCity[city])
        }
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
Istanbul    12610000
Karachi     10620000
Mumbai      12690000
Shanghai    13680000
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-6&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-6&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.6&lt;/span&gt; 映射反转&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-6&quot;&gt;
&lt;p&gt;
上节实现的是按键顺序输出映射，要实现按值顺序输出也是可以的。如果一个映射的值都是唯一的，而且值的类型也是映射支持的键类型。那么很容易将它反转。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        populationForCity := &lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt;: 12610000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;:  10620000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;:   12690000,
                &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;: 13680000,
        }

        cityForPopulation := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(populationForCity))
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; city, population := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; populationForCity {
                cityForPopulation[population] = city
        }

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(cityForPopulation)
}
&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&lt;span style=&quot;color: #00ffff;&quot;&gt;map&lt;/span&gt;[&lt;span style=&quot;color: #ffff00;&quot;&gt;10620000&lt;/span&gt;:Karachi 12690000:Mumbai 13680000:Shanghai 12610000:Istanbul]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
记住映射里的值必须是唯一的，不然只能保存最后一个。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/09/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/09/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>Go语言程序设计读书笔记（七）——集合类型之数组与切片</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第4章 集合类型(一)数组与切片&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. 值、指针和引用类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. 数组和切片&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-1&quot;&gt;1.2.1. 数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2&quot;&gt;1.2.2. 切片&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2-1&quot;&gt;1.2.2.1. 索引与分割切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2-2&quot;&gt;1.2.2.2. 遍历切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2-3&quot;&gt;1.2.2.3. 修改切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2-4&quot;&gt;1.2.2.4. 排序和搜索切片&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第4章 集合类型(一)数组与切片&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; 值、指针和引用类型&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
通常情况下，Go语言的变量持有相应的值。也就是说，我们可以将一个变量想像成它所持有的值来使用。其中有些例外，对于通道、函数、方法、映射及切片的引用变量，它们持有的都是引用，也即保存指针的变量。
&lt;/p&gt;

&lt;p&gt;
Go语言中函数和方法是值传递的。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;对于布尔变量、数值类型和字符串按值传递是非常廉价的，也就1～16个字节（视机器而定）。但是如果修改了一个传入的字符串（例如使用+=操作符），因需创建一个新的字符串，并且复制原始的字符串并将其加到该字符串之后，所以这对于大字符串来说代价将非常大。
&lt;/li&gt;
&lt;li&gt;数组也是值传递，因此传递一个大数组代价也很大。在Go中，一般使用切片代替数组来传递。
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
如果需要一个函数修改我们传入的值。由于值类型是复制的，因此任何修改只作用于其副本，原始值不会被改变。同时传值的成本也较大。这种情况下，一般使用指针。
&lt;/p&gt;

&lt;p&gt;
Go语言的指针跟c/c++大致一样，但不支持指针运算。
&lt;/p&gt;


&lt;p&gt;
常用情况：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;需要在一个函数或方法中返回超过四五个值的情况时，如果这些值是同一类型的，最好使用一个切片来传递。
&lt;/li&gt;
&lt;li&gt;如果值类型各异最好传递一个指向结构体的指针。
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
除了值和指针外，Go语言还有引用类型（另外还有接口类型，但大多数实际使用中可以把接口看成某种类型的引用，引用类型将地6.3节接触）。Go语言中的引用类型主要有：映射、切片、通道、函数和方法。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; 数组和切片&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-2-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-2-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.2.1&lt;/span&gt; 数组&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-2-1&quot;&gt;
&lt;p&gt;
Go语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。
&lt;/p&gt;

&lt;p&gt;
数组的元素使用操作符[]来索引，索引从0开始。数组是可以更改的（字符串不能更改）。
&lt;/p&gt;

&lt;p&gt;
数组使用以下方法来创建：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;[length]Type
[N]&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;{value1, value2, value3..., valueN}
[...]&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;{value1, value2, ...,valueN} &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#30465;&amp;#30053;&amp;#31526;...&amp;#65292;Go&amp;#20250;&amp;#33258;&amp;#21160;&amp;#35745;&amp;#31639;&amp;#25968;&amp;#32452;&amp;#38271;&amp;#24230;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
以下示例展示了如何创建和索引数组：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main
&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; buffer [20]&lt;span style=&quot;color: #ffff00;&quot;&gt;byte&lt;/span&gt;
        &lt;span style=&quot;color: #00ffff;&quot;&gt;var&lt;/span&gt; grid1 [3][3]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;
        grid1[1][0], grid1[1][1], grid1[1][2] = 8, 6, 2
        grid2 := [3][3]&lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;{ 
                            {4, 3}, 
                            {8, 6, 2} 
                          }

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(grid1, grid2)

        cities := [...]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Beijing&quot;&lt;/span&gt;}
        cities[&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(cities)-1] = &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Type Len Contents&quot;&lt;/span&gt;)
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%-8T %2d %v\n&quot;&lt;/span&gt;, buffer, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(buffer), buffer)
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%-8T %2d %q\n&quot;&lt;/span&gt;, cities, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(cities), cities)
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&amp;#36816;&amp;#34892;&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;

[[0 0 0] [8 6 2] [0 0 0]] [[4 3 0] [8 6 2] [0 0 0]]
Type Len Contents
[20]&lt;span style=&quot;color: #ffff00;&quot;&gt;uint8&lt;/span&gt; 20 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[4]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;  4 [&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Shanghai&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Mumbai&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Istanbul&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Karachi&quot;&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
未初始化的数组元素都为0。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-2-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.2.2&lt;/span&gt; 切片&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-2-2&quot;&gt;
&lt;p&gt;
一般而言，切片比数组更加灵活、强大而且方便。数组是值传递的，切片是引用传递，效率更高。Go语言标准库中的所有公开函数使用的都是切片而非数组。除非特别情况，不然的话都使用切片而非数组。
&lt;/p&gt;

&lt;p&gt;
Go语言的切片是长度可变、容量固定（可以通过将其切片来收缩或使用内置的append()函数来增长）的相同类型元素的序列。
&lt;/p&gt;

&lt;p&gt;
切片的创建：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;, length, capacity)
&lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;, length)
[]&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;{}
[]&lt;span style=&quot;color: #ffff00;&quot;&gt;Type&lt;/span&gt;{value1, value2, value3, ... , valueN}
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
内置函数make()用于创建切片、映射和通道。当用于创建切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。
&lt;/p&gt;

&lt;table border=&quot;2&quot; cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; rules=&quot;groups&quot; frame=&quot;hsides&quot;&gt;
&lt;caption class=&quot;t-above&quot;&gt;&lt;span class=&quot;table-number&quot;&gt;Table 1:&lt;/span&gt; 切片的操作&lt;/caption&gt;

&lt;colgroup&gt;
&lt;col  class=&quot;left&quot; /&gt;

&lt;col  class=&quot;left&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;语法&lt;/th&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;含义/结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;s[n]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;切片s中索引位置为n的项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;s[n:m]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从切片s的索引位置n到m-1处所获得的切片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;s[n:]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从切片s的索引位置n到len(s)-1处所获得的切片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;s[:m]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从切片s的索引位置0到m-1处所获得的切片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;s[:]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;从切片s的索引位置0到len(s)-1处所获得的切片&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;cap(s)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;切片s的容量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;len(s)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;切片s中所包含项的个数;总是&amp;lt;=cap(s)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;s[:cap(s)]&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;增加切片s的长度到其容量，如果两者不同的话&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2-2-1&quot; class=&quot;outline-5&quot;&gt;
&lt;h5 id=&quot;sec-1-2-2-1&quot;&gt;&lt;span class=&quot;section-number-5&quot;&gt;1.2.2.1&lt;/span&gt; 索引与分割切片&lt;/h5&gt;
&lt;div class=&quot;outline-text-5&quot; id=&quot;text-1-2-2-1&quot;&gt;
&lt;p&gt;
一个切片是一个隐藏数组的引用，并且对于该切片的切片也引用同一个数组。通过原始切片或切片的切片，都会改变底层切片。任何切片的第一个索引位置都是0,最后一个都是len(s)-1。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        s := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;E&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;G&quot;&lt;/span&gt;}
        t := s[2:6]
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(t, s, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;=&quot;&lt;/span&gt;, s[:4], &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;+&quot;&lt;/span&gt;, s[4:])
        s[3] = &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;x&quot;&lt;/span&gt;
        t[&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(t)-1] = &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;y&quot;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(t, s, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;=&quot;&lt;/span&gt;, s[:4], &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;+&quot;&lt;/span&gt;, s[4:])
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
[C D E F] [A B C D E F G] = [A B C D] + [E F G]
[C x E y] [A B C x E y G] = [A B C x] + [E y G]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2-2-2&quot; class=&quot;outline-5&quot;&gt;
&lt;h5 id=&quot;sec-1-2-2-2&quot;&gt;&lt;span class=&quot;section-number-5&quot;&gt;1.2.2.2&lt;/span&gt; 遍历切片&lt;/h5&gt;
&lt;div class=&quot;outline-text-5&quot; id=&quot;text-1-2-2-2&quot;&gt;
&lt;p&gt;
要取得切片中的某个元素而不想修改它，可以使用for&amp;#x2026;range循环，如果想修改它则可以使用for循环。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        amounts := []&lt;span style=&quot;color: #ffff00;&quot;&gt;float64&lt;/span&gt;{237.81, 261.87, 273.93, 279.99, 281.07, 303.17,
                231.47, 227.33, 209.23, 197.09}
        sum := 0.0
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; _, amount := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; amounts {
                sum += amount
        }
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;&amp;#8721; %.1f&amp;#8594; %.1f\n&quot;&lt;/span&gt;, amounts, sum)
}

&amp;#32467;&amp;#26524;&amp;#65306;
&amp;#8721; [237.8 261.9 273.9 280.0 281.1 303.2 231.5 227.3 209.2 197.1]&amp;#8594; 2503.0
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
如果想修改切片的项，必须使用可以提供有效切片索引而非仅仅是元素副本的for循环。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        amounts := []&lt;span style=&quot;color: #ffff00;&quot;&gt;float64&lt;/span&gt;{237.81, 261.87, 273.93, 279.99, 281.07, 303.17,
                231.47, 227.33, 209.23, 197.09}
        sum := 0.0
        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; amounts {
                amounts[i] *= 1.05
                sum += amounts[i]
        }

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;&amp;#8721; %.1f&amp;#8594; %.1f\n&quot;&lt;/span&gt;, amounts, sum)
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&amp;#8721; [249.7 275.0 287.6 294.0 295.1 318.3 243.0 238.7 219.7 206.9]&amp;#8594; 2628.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2-2-3&quot; class=&quot;outline-5&quot;&gt;
&lt;h5 id=&quot;sec-1-2-2-3&quot;&gt;&lt;span class=&quot;section-number-5&quot;&gt;1.2.2.3&lt;/span&gt; 修改切片&lt;/h5&gt;
&lt;div class=&quot;outline-text-5&quot; id=&quot;text-1-2-2-3&quot;&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;在切片末尾追加元素或切片
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
在一个切片的末尾追加一个或多个元素甚至是其它切片，可以使用append()函数。这个函数接受一个需要被追加的切片，以及一个或多个需要加入的元素。如果需要在一个切片末尾追加另一个切片，那必须使用&amp;#x2026;操作符来告诉Go语言将被添加进来的切片当成多个元素。追加的元素或切片必须和原切片类型相同 。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        s := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;E&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;G&quot;&lt;/span&gt;}
        t := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;K&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;L&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;M&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;N&quot;&lt;/span&gt;}
        u := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;m&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;n&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;o&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;p&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;q&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;r&quot;&lt;/span&gt;}

        s = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(s, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;h&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;i&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;j&quot;&lt;/span&gt;) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#36861;&amp;#21152;&amp;#21333;&amp;#19968;&amp;#30340;&amp;#20540;&lt;/span&gt;
        s = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(s, t...)          &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#36861;&amp;#21152;&amp;#20999;&amp;#29255;&amp;#20013;&amp;#30340;&amp;#25152;&amp;#26377;&amp;#20540;&lt;/span&gt;
        s = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(s, u[2:5]...)     &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#28155;&amp;#21152;&amp;#19968;&amp;#20010;&amp;#23376;&amp;#20999;&amp;#29255;&lt;/span&gt;
        b := []&lt;span style=&quot;color: #ffff00;&quot;&gt;byte&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&#39;U&#39;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&#39;V&#39;&lt;/span&gt;}
        letters := &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;WXY&quot;&lt;/span&gt;
        b = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(b, letters...) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#23558;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#31526;&amp;#20018;&amp;#23383;&amp;#33410;&amp;#28155;&amp;#21152;&amp;#36827;&amp;#19968;&amp;#20010;&amp;#23383;&amp;#33410;&amp;#20999;&amp;#29255;&amp;#20013;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%v\n%s\n&quot;&lt;/span&gt;, s, b)
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
[A B C D E F G h i j K L M N o p q]
UVWXY
&lt;/pre&gt;
&lt;/div&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;在切片的任意位置追加元素或切片，并且不改变原切片，使用InsertStringSliceCipy()自定义函数。
&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        s := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;M&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;N&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;O&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;P&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Q&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;R&quot;&lt;/span&gt;}
        x := &lt;span style=&quot;color: #00fa9a;&quot;&gt;InsertStringSliceCopy&lt;/span&gt;(s, []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;c&quot;&lt;/span&gt;}, 0) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#22312;&amp;#20999;&amp;#29255;&amp;#36215;&amp;#21021;&amp;#22788;&amp;#28155;&amp;#21152;&amp;#20999;&amp;#29255;&lt;/span&gt;
        y := &lt;span style=&quot;color: #00fa9a;&quot;&gt;InsertStringSliceCopy&lt;/span&gt;(s, []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;x&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;y&quot;&lt;/span&gt;}, 3)      &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#22312;&amp;#20999;&amp;#29255;&amp;#20013;&amp;#38388;&amp;#22788;&amp;#28155;&amp;#21152;&amp;#20999;&amp;#29255;&lt;/span&gt;
        z := &lt;span style=&quot;color: #00fa9a;&quot;&gt;InsertStringSliceCopy&lt;/span&gt;(s, []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;z&quot;&lt;/span&gt;}, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(s))      &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#22312;&amp;#20999;&amp;#29255;&amp;#26411;&amp;#23614;&amp;#28155;&amp;#21152;&amp;#20803;&amp;#32032;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%v\n%v\n%v\n&quot;&lt;/span&gt;, x, y, z)
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;InsertStringSliceCopy&lt;/span&gt;(slice, insertion []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, index &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {
        result := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(slice)+&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(insertion))
        at := &lt;span style=&quot;color: #b0c4de;&quot;&gt;copy&lt;/span&gt;(result, slice[:index])
        at += &lt;span style=&quot;color: #b0c4de;&quot;&gt;copy&lt;/span&gt;(result[at:], insertion)
        &lt;span style=&quot;color: #b0c4de;&quot;&gt;copy&lt;/span&gt;(result[at:], slice[index:])
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; result
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
[a b c M N O P Q R]
[M N O x y P Q R]
[M N O P Q R z]
&lt;/pre&gt;
&lt;/div&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;删除切片元素。利用Go语言的标准切片语法就可以将元素从切片的头尾和中间处删除，这样做会改变原切片。这种删除切片元素的方法其实是对原切片进行再切片。
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        s := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;E&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;G&quot;&lt;/span&gt;}
        s = s[2:] &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20174;&amp;#24320;&amp;#22836;&amp;#21024;&amp;#38500;&amp;#20803;&amp;#32032;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(s)

        s = []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;E&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;G&quot;&lt;/span&gt;}
        s = s[:4] &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20174;&amp;#26411;&amp;#23614;&amp;#21024;&amp;#38500;&amp;#20803;&amp;#32032;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(s)

        s = []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;E&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;G&quot;&lt;/span&gt;}
        s = &lt;span style=&quot;color: #b0c4de;&quot;&gt;append&lt;/span&gt;(s[:1], s[5:]...) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20174;&amp;#20013;&amp;#38388;&amp;#21024;&amp;#38500;&amp;#20803;&amp;#32032;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Println&lt;/span&gt;(s)
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
[C D E F G]
[A B C D]
[A F G]
&lt;/pre&gt;
&lt;/div&gt;

&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;利用自定义函数RemoveStringSliceCopy(),可以在任意位置删除切片元素，又可以保持原切片完整。
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        s := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;C&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;D&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;E&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;F&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;G&quot;&lt;/span&gt;}
        x := &lt;span style=&quot;color: #00fa9a;&quot;&gt;RemoveStringSliceCopy&lt;/span&gt;(s, 0, 2)      &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20174;&amp;#22836;&amp;#37096;&amp;#21024;&amp;#38500;s[:2]&lt;/span&gt;
        y := &lt;span style=&quot;color: #00fa9a;&quot;&gt;RemoveStringSliceCopy&lt;/span&gt;(s, 1, 5)      &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20174;&amp;#20013;&amp;#38388;&amp;#21024;&amp;#38500;s[1:5]&lt;/span&gt;
        z := &lt;span style=&quot;color: #00fa9a;&quot;&gt;RemoveStringSliceCopy&lt;/span&gt;(s, 4, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(s)) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#20174;&amp;#26411;&amp;#23614;&amp;#21024;&amp;#38500;s[4:]&lt;/span&gt;

        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%v\n%v\n%v\n%v\n&quot;&lt;/span&gt;, s, x, y, z)
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;RemoveStringSliceCopy&lt;/span&gt;(slice []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, start, end &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt; {
        result := &lt;span style=&quot;color: #b0c4de;&quot;&gt;make&lt;/span&gt;([]&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;, &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(slice)-(end-start))
        at := &lt;span style=&quot;color: #b0c4de;&quot;&gt;copy&lt;/span&gt;(result, slice[:start])
        &lt;span style=&quot;color: #b0c4de;&quot;&gt;copy&lt;/span&gt;(result[at:], slice[end:])
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; result
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
[A B C D E F G]
[C D E F G]
[A F G]
[A B C D]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2-2-4&quot; class=&quot;outline-5&quot;&gt;
&lt;h5 id=&quot;sec-1-2-2-4&quot;&gt;&lt;span class=&quot;section-number-5&quot;&gt;1.2.2.4&lt;/span&gt; 排序和搜索切片&lt;/h5&gt;
&lt;div class=&quot;outline-text-5&quot; id=&quot;text-1-2-2-4&quot;&gt;
&lt;p&gt;
标准库的sort包提供了对整型、浮点型和字符串型切片进行排序的函数，检查一个切片是否排序好的函数，以及使用二分搜索算法在一个有序切片中搜索一个元素的函数。同时提供了通用的sorg.Sort()和sorg.Search()函数，可用于任何自定义的数据。
&lt;/p&gt;

&lt;table border=&quot;2&quot; cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; rules=&quot;groups&quot; frame=&quot;hsides&quot;&gt;
&lt;caption class=&quot;t-above&quot;&gt;&lt;span class=&quot;table-number&quot;&gt;Table 2:&lt;/span&gt; sort包中的函数&lt;/caption&gt;

&lt;colgroup&gt;
&lt;col  class=&quot;left&quot; /&gt;

&lt;col  class=&quot;left&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;语法&lt;/th&gt;
&lt;th scope=&quot;col&quot; class=&quot;left&quot;&gt;含义/结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.Float64s(fs)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;将[]float64按升序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.Float64AreSorted(fs)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;如果[]float64是有序的则返回true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.Insts(is)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;将[]int按升序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.InstsAreSorted(is)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;如果[]int是有序的则返回true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.IsSorted(d)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;如果sort.InterFace的值d是有序的，则返回true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.Search(size, fn)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;在一个排序好的数组中根据函数签名为func(int)bool的函数fn进行搜索，&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;返回第一个使得函数fn返回值为true的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.SearchFloat64s(fs, f)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;返回有序[]float64切片fs中类型为float64的值f的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.SearchInts(is, i)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;返回有序[]int切片中类型为int的值i的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.SearchStrings(ss, s)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;返回有序[]string切片ss中类型为string的值s的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.Sort(d)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;排序类型为sorg.Interface的切片d&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.Strings(ss)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;按升序排序[]string类型的切片ss&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;left&quot;&gt;sort.StringsAreSorted(ss)&lt;/td&gt;
&lt;td class=&quot;left&quot;&gt;如果[]string类型的切片ss是有序的，则返回true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;切片的排序
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Go语言对数值的排序没什么可说的，可对字符串的排序则完全是字节排序，这意味着字符串的排序是区分大小写的。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;sort&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;strings&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        files := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt;}
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Unsrted:          %q\n&quot;&lt;/span&gt;, files)
        sort.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Strings&lt;/span&gt;(files) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#26631;&amp;#20934;&amp;#24211;&amp;#20013;&amp;#30340;&amp;#25490;&amp;#24207;&amp;#20989;&amp;#25968;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Underlying bytes: %q\n&quot;&lt;/span&gt;, files)
        &lt;span style=&quot;color: #00fa9a;&quot;&gt;SortFoldedStrings&lt;/span&gt;(files) &lt;span style=&quot;color: #ffd700;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;&amp;#33258;&amp;#23450;&amp;#20041;&amp;#25490;&amp;#24207;&amp;#20989;&amp;#25968;&lt;/span&gt;
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Case insensitive: %q\n&quot;&lt;/span&gt;, files)
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;SortFoldedStrings&lt;/span&gt;(slice []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;) {
        sort.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Sort&lt;/span&gt;(&lt;span style=&quot;color: #00fa9a;&quot;&gt;FoldedStrings&lt;/span&gt;(slice))
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;type&lt;/span&gt; &lt;span style=&quot;color: #ffff00;&quot;&gt;FoldedStrings&lt;/span&gt; []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; (slice &lt;span style=&quot;color: #ffff00;&quot;&gt;FoldedStrings&lt;/span&gt;) &lt;span style=&quot;color: #00fa9a;&quot;&gt;Len&lt;/span&gt;() &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt; { &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(slice) }

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; (slice &lt;span style=&quot;color: #ffff00;&quot;&gt;FoldedStrings&lt;/span&gt;) &lt;span style=&quot;color: #00fa9a;&quot;&gt;Less&lt;/span&gt;(i, j &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; {
        &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; strings.&lt;span style=&quot;color: #00fa9a;&quot;&gt;ToLower&lt;/span&gt;(slice[i]) &amp;lt; strings.&lt;span style=&quot;color: #00fa9a;&quot;&gt;ToLower&lt;/span&gt;(slice[j])
}

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; (slice &lt;span style=&quot;color: #ffff00;&quot;&gt;FoldedStrings&lt;/span&gt;) &lt;span style=&quot;color: #00fa9a;&quot;&gt;Swap&lt;/span&gt;(i, j &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) {
        slice[i], slice[j] = slice[j], slice[i]
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
&lt;span style=&quot;color: #fa8072;&quot;&gt;Unsrted&lt;/span&gt;:          [&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt;]
Underlying bytes: [&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt;]
Case insensitive: [&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt;]
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
sort.Sort()函数能够对任意类型进行排序，只要其类型提供了sort.Interface接口中定义的方法，即只要这些类型根据相应的签名实现了Len()、Less()和Swap()方法。
&lt;/p&gt;

&lt;p&gt;
SortFoldedStrings()函数简单地使用标准库中的sort.Srot()函数来完成工作，即使用Go语言的标准转换语法将给定的[]string类型的值转换成FoldedStrings类型的值。其实现了3个方法以对应sort.Interface接口。Less()方法通过使用strings.ToLower()函数来达到大小写无关。
&lt;/p&gt;


&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;切片的搜索
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
对于无序数据来说，我们可以使用for&amp;#x2026;range线性搜索。对于小切片（大至上百个元素）来说，效果还不错。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        files := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt;}
        target := &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt;

        &lt;span style=&quot;color: #00ffff;&quot;&gt;for&lt;/span&gt; i, file := &lt;span style=&quot;color: #00ffff;&quot;&gt;range&lt;/span&gt; files {
                &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; file == target {
                        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;found \&quot;%s\&quot; at files[%d]\n&quot;&lt;/span&gt;, file, i)
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;break&lt;/span&gt;
                }
        }
}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
found &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt; at files[2]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
对于大切片特别是如果需要进行重复搜索的话，线性搜索非常低效，平均每次都需要让一半元素相互比较。Go提供了一个使用二分搜索算法的sort.Search()方法，每次只需比较log&lt;sub&gt;2&lt;/sub&gt;n个元素。
&lt;/p&gt;

&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-go&quot;&gt;&lt;span style=&quot;color: #00ffff;&quot;&gt;package&lt;/span&gt; main

&lt;span style=&quot;color: #00ffff;&quot;&gt;import&lt;/span&gt; (
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
        &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;sort&quot;&lt;/span&gt;
)

&lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;main&lt;/span&gt;() {
        files := []&lt;span style=&quot;color: #ffff00;&quot;&gt;string&lt;/span&gt;{&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt;, &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt;}
        target := &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt;
        sort.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Strings&lt;/span&gt;(files)
        fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;%q\n&quot;&lt;/span&gt;, files)
        i := sort.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Search&lt;/span&gt;(&lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(files),
                &lt;span style=&quot;color: #00ffff;&quot;&gt;func&lt;/span&gt;(i &lt;span style=&quot;color: #ffff00;&quot;&gt;int&lt;/span&gt;) &lt;span style=&quot;color: #ffff00;&quot;&gt;bool&lt;/span&gt; { &lt;span style=&quot;color: #00ffff;&quot;&gt;return&lt;/span&gt; files[i] &amp;gt;= target })
        &lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; i &amp;lt; &lt;span style=&quot;color: #b0c4de;&quot;&gt;len&lt;/span&gt;(files) &amp;amp;&amp;amp; files[i] == target {
                fmt.&lt;span style=&quot;color: #00fa9a;&quot;&gt;Printf&lt;/span&gt;(&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;found \&quot;%s\&quot; at files[%d]\n&quot;&lt;/span&gt;, files[i], i)
        }

}

&amp;#32467;&amp;#26524;&amp;#20026;&amp;#65306;
[&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Test.conf&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;main.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;misc.go&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;util.go&quot;&lt;/span&gt;]
found &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Makefile&quot;&lt;/span&gt; at files[0]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/golang/2014/11/08/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/golang/2014/11/08/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89.html</guid>
        
        <category>golang</category>
        
        
        <category>golang</category>
        
      </item>
    
  </channel>
</rss>
