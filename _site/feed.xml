<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行之博客</title>
    <description>Linux / C / golang / Emacs</description>
    <link>http://xep007.github.io/</link>
    <atom:link href="http://xep007.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 22 Oct 2014 21:45:06 +0800</pubDate>
    <lastBuildDate>Wed, 22 Oct 2014 21:45:06 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>GNU Emacs Lisp编程入门笔记（六）</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第7章 基本函数：car、cdr、cons&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. car和cdr函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. cons函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. nthcdr函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. setcar函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5&quot;&gt;1.5. setcdr函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第7章 基本函数：car、cdr、cons&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
在Lisp中，car、cdr、cons都是基本函数。cons函数用于构造列表，car和cdr函数则用于拆分列表。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; car和cdr函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
一个列表的car，就是返回这个列表的第一个元素。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(car &#39;(rose violet daisy buttercup))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
得到结果为“rose”。
car并不改变列表。只是返回列表的第一个元素。
一个列表的cdr就是一个列表第一个元素之后的所有元素。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(car &#39;(rose violet daisy buttercup))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
结果为“(violet daisy buttercup)”。cdr也不改变原列表。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; cons函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
cons函数可以构造列表，其作用与car和cdr函数正好相反。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(cons &#39;pine &#39;(fir oak maple))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
结果为“(pine fir oak maple)”。cons必须提供一个待插入元素的列表，哪怕是空列表。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;查询列表的长度：length函数&lt;/b&gt;
通过Lisp的length函数可以得到一个列表的长度。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(length &#39;(a b c))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
结果为3。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(length (cons &#39;a &#39;(b c d e)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
结果为5。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; nthcdr函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
nthcdr函数,其所做之事就是重复地取列表的cdr。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(nthcdr 2 &#39;(pine fir oak maple))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
结果为(oak maple)。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(netcdr 4 &#39;(pine fir oak maple))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
结果为nil。nthcdr也不会改变原列表。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; setcar函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
setcar函数会改变列表的值。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(setq animals &#39;(giraffe antelope tiger lion))  
&lt;span class=&quot;linenr&quot;&gt;2: &lt;/span&gt;(setcar animals &#39;hippopotamus)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
第一行代码构造一个列表，并把列表赋值给变量animals。第二行代码：这时变量animals的值变成了(hippopotamus antelope tiger lion),列表的第一个值被替换了。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-5&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.5&lt;/span&gt; setcdr函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-5&quot;&gt;
&lt;p&gt;
与setcar函数相似，不同之处在于这个函数替换列表的第二个以及其后的所有元素。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(setq domesticated-animals &#39;(horse cow sheep goat))
&lt;span class=&quot;linenr&quot;&gt;2: &lt;/span&gt;(setcdr domesticated-animals &#39;(cat dog))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
现在domesticated-animals的值变成了(horse cat dog)。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 22 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/emacs/lisp/2014/10/22/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/emacs/lisp/2014/10/22/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89.html</guid>
        
        
        <category>emacs</category>
        
        <category>lisp</category>
        
      </item>
    
      <item>
        <title>GNU Emacs Lisp编程入门笔记（五）</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第5章 更复杂的函数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. copy-to-buffer函数的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. insert-buffer函数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-1&quot;&gt;1.2.1. insert-buff函数中的交互表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2-2&quot;&gt;1.2.2. insert-buffer函数体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 其余略&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第5章 更复杂的函数&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; copy-to-buffer函数的定义&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
copy-to-buffer函数拷贝文本到一个缓冲区，替换原有缓冲区中的文本。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;copy-to-buffer&lt;/span&gt; buffer start end
&lt;span class=&quot;linenr&quot;&gt;2: &lt;/span&gt;    (interactive &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;BCopy to buffer: \nr&quot;&lt;/span&gt;)
&lt;span class=&quot;linenr&quot;&gt;3: &lt;/span&gt;        (&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; ((oldbuf (current-buffer)))
&lt;span class=&quot;linenr&quot;&gt;4: &lt;/span&gt;            (&lt;span style=&quot;color: #00ffff;&quot;&gt;save-excursion&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;5: &lt;/span&gt;               (set-buffer (get-buffer-create buffer))
&lt;span class=&quot;linenr&quot;&gt;6: &lt;/span&gt;               (erase-buffer)
&lt;span class=&quot;linenr&quot;&gt;7: &lt;/span&gt;               (&lt;span style=&quot;color: #00ffff;&quot;&gt;save-excursion&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;8: &lt;/span&gt;                  (insert-buffer-substring oldbuf start end)))))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
(erase-buffer)删除了缓冲区原有的内容。第一次使用save-excurision函数返回到将要拷贝文本的缓冲区。第二次使用是使Emacs在被插入内容的缓冲区的域的开始设置位点。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; insert-buffer函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
此命令将另外一个缓冲区的内容拷贝到当前缓冲区中。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt; 1: &lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;insert-buffer&lt;/span&gt; (buffer)
&lt;span class=&quot;linenr&quot;&gt; 2: &lt;/span&gt;  (interactive &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;*bInsert buffer: &quot;&lt;/span&gt;)
&lt;span class=&quot;linenr&quot;&gt; 3: &lt;/span&gt;  (or (bufferp buffer)
&lt;span class=&quot;linenr&quot;&gt; 4: &lt;/span&gt;      (setq buffer (get-buffer buffer)))
&lt;span class=&quot;linenr&quot;&gt; 5: &lt;/span&gt;  (&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; (start end newmark)
&lt;span class=&quot;linenr&quot;&gt; 6: &lt;/span&gt;    (&lt;span style=&quot;color: #00ffff;&quot;&gt;save-excursion&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 7: &lt;/span&gt;      (&lt;span style=&quot;color: #00ffff;&quot;&gt;save-excursion&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 8: &lt;/span&gt;      (set-buffer buffer)
&lt;span class=&quot;linenr&quot;&gt; 9: &lt;/span&gt;      (setq start (point-min) end (point max)))
&lt;span class=&quot;linenr&quot;&gt;10: &lt;/span&gt;      (insert-buffer-substring buffer start end)
&lt;span class=&quot;linenr&quot;&gt;11: &lt;/span&gt;      (setq newmark (point)))
&lt;span class=&quot;linenr&quot;&gt;12: &lt;/span&gt;    (push-mark newmark)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-2-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.2.1&lt;/span&gt; insert-buff函数中的交互表达式&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-2-1&quot;&gt;
&lt;p&gt;
interactive表达式的参量有两个部分：一部分是一个星号“*”， 另一部分是“bInsert buffer: ”。
&lt;/p&gt;
&lt;ol class=&quot;org-ol&quot;&gt;
&lt;li&gt;只读缓冲区。星号用于缓冲区是一个只读缓冲区的情况。如果insert-buffer被一个只读缓冲区调用，一条消息将打印在回显区。警告不允许往这个缓冲区写入任何东西。
&lt;/li&gt;
&lt;li&gt;交互表达式的中“b”
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
小写的“b”告诉lisp解释器传送给insert-buffer函数的参量应是一个存在缓冲区或者这个缓冲区的名字。大写的“B”可以允许参量传送不存在的缓冲区。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-2-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.2.2&lt;/span&gt; insert-buffer函数体&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-2-2&quot;&gt;
&lt;p&gt;
函数体有两个主要部分：一个or表达式和一个let表达式。or表达式的目的是为了确保buffer参量真正与一个缓冲区绑定在一起，而不是绑定到缓冲区的名字。let表达式包含了将另外一个缓冲区的内容拷贝到当前缓冲区所需的代码。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 其余略&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 22 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/emacs/lisp/2014/10/22/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/emacs/lisp/2014/10/22/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html</guid>
        
        
        <category>emacs</category>
        
        <category>lisp</category>
        
      </item>
    
      <item>
        <title>GNU Emacs Lisp 编程入门笔记（四）</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第4章 与缓冲区有关的函数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. 查找更多的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. 简化的beginning-of-buffer函数定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. make-whole-buffer函数的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. append-to-buffer函数的定义&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4-1&quot;&gt;1.4.1. append-to-buffer函数的交互表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4-2&quot;&gt;1.4.2. append-to-buffer函数体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4-3&quot;&gt;1.4.3. append-to-buffer函数中的save-excursion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5&quot;&gt;1.5. 回顾&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第4章 与缓冲区有关的函数&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; 查找更多的信息&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
在任何时候，你都可以键入C-h f以及函数名，得到Emacs Lisp函数的全部文档。键入C-h v 和变量名得到任何变量的全部文档。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; 简化的beginning-of-buffer函数定义&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
完整版的beginning-of-buffer函数见下一章。以下是简化版的。代码如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;beginning-of-buffer&lt;/span&gt; ()
&lt;span class=&quot;linenr&quot;&gt;2: &lt;/span&gt;    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Move point to the beginning of the buffer;&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;3: &lt;/span&gt;&lt;span style=&quot;color: #ffa500;&quot;&gt;leave mark at previous position.&quot;&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;4: &lt;/span&gt;    (interactive)
&lt;span class=&quot;linenr&quot;&gt;5: &lt;/span&gt;    (push-mark)
&lt;span class=&quot;linenr&quot;&gt;6: &lt;/span&gt;    (goto-char (point-min)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
(push-mark)表达式表示在光标的当前位置设置一个标记。这个标记被保存在标记环中。
(goto-char)表达式表示将光标跳到本缓冲区的最小可能位点处，也就是缓冲区的开始处。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; make-whole-buffer函数的定义&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
make-whole-buffer函数将整个缓冲区作为一个域来标记，方法是将位点置于缓冲区开始的位置，在缓冲区的末尾放一个标记。其完整代码如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt;1: &lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;mark-whole-buffer&lt;/span&gt; () 
&lt;span class=&quot;linenr&quot;&gt;2: &lt;/span&gt;    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Put point at beginning and mark at end of buffer.&quot;&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;3: &lt;/span&gt;    (interactive)
&lt;span class=&quot;linenr&quot;&gt;4: &lt;/span&gt;    (push-mark (point))
&lt;span class=&quot;linenr&quot;&gt;5: &lt;/span&gt;    (push-mark (point-max))
&lt;span class=&quot;linenr&quot;&gt;6: &lt;/span&gt;    (goto-char (point-min)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
函数体有三行。
((push-mark (point)),这一行与(push-mark)的作用一样。即在当前位置设置一个标记。不加(point)也是可以的。
(push-mark (point-max)),这个表达式在缓冲区中数值最大的位点处（缓冲区末尾）设置一个标记。设置好这一标记后，原来的标记就不是标记了，但Emacs记住了它的位置。
(goto-char (point-min)),这个表达式与上一个函数中的一样。
这个函数的作用就是标记了整个缓冲区。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; append-to-buffer函数的定义&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
append-to-buffer函数功能是从当前缓冲区中拷贝一个域（即缓冲区中介于位点和标记之间的域）到一个指定的缓冲区。代码如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span class=&quot;linenr&quot;&gt; 1: &lt;/span&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;append-to-buffer&lt;/span&gt; (buffer start end)
&lt;span class=&quot;linenr&quot;&gt; 2: &lt;/span&gt;    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Append to specified buffer the text of the region.&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 3: &lt;/span&gt;&lt;span style=&quot;color: #ffa500;&quot;&gt;     It is inserted into that buffer before its point.&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 4: &lt;/span&gt;&lt;span style=&quot;color: #ffa500;&quot;&gt;    When calling from a program, give three arguments:&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 5: &lt;/span&gt;&lt;span style=&quot;color: #ffa500;&quot;&gt;    a buffer or the name of one, and two charactre number&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 6: &lt;/span&gt;&lt;span style=&quot;color: #ffa500;&quot;&gt;    apecifying the portion of the current buffer to be copied.&quot;&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt; 7: &lt;/span&gt;    (interactive &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;BAppend to buffer: \nr&quot;&lt;/span&gt;)
&lt;span class=&quot;linenr&quot;&gt; 8: &lt;/span&gt;    (&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; ((oldbuf (current-buffer)))
&lt;span class=&quot;linenr&quot;&gt; 9: &lt;/span&gt;       (&lt;span style=&quot;color: #00ffff;&quot;&gt;save-excursion&lt;/span&gt;
&lt;span class=&quot;linenr&quot;&gt;10: &lt;/span&gt;           (set-buffer (get-buffer-create buffer))
&lt;span class=&quot;linenr&quot;&gt;11: &lt;/span&gt;           (insert-buffer-substring oldbuf start end))))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
函数定义的第一行包含了函数名以及三个参量。buffer参量是指拷贝文本的目的缓冲区，start和end参量是指将要被拷贝的当前缓冲区中指定域的起始和终止位点。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-4-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.4.1&lt;/span&gt; append-to-buffer函数的交互表达式&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-4-1&quot;&gt;
&lt;p&gt;
交互表达式interactive的参量有两个部分，用&quot;\n&quot;分隔。
参量第一部分是&quot;BAppend to buffer:&quot;。&quot;B&quot;控制符告诉Emacs要求输入缓冲区的名字并将这个名字传送给函数。Emacs将在minibuffer中打印出&quot;B&quot;字符后面的字符串&quot;Append to buffer:&quot;来提示用户输入这个缓冲区名。然后Emacs将函数参量列表中的参量buffer绑定到指定的缓冲区.
&quot;r&quot;,告诉Emacs将函数参量列表中符号&quot;buffer&quot;之后的两个参量（即start和end）绑定到位点和标记上。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-4-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.4.2&lt;/span&gt; append-to-buffer函数体&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-4-2&quot;&gt;
&lt;p&gt;
函数体从let开始。let表达式有三个元素：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;符号let;
&lt;/li&gt;
&lt;li&gt;一个变量列表，本例中，变量列表包含一个两元素列表（variable value）;
&lt;/li&gt;
&lt;li&gt;let表达式主体。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4-3&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-4-3&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.4.3&lt;/span&gt; append-to-buffer函数中的save-excursion&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-4-3&quot;&gt;
&lt;p&gt;
let表达式的主体由一个save-excursion表达式组成。它保存位点和标记的位置，并当这个函数体的其他表达式都被求值之后恢复位点和标记到相应的位置。
(set-buffer (get-buffer-create buffer))列表中，(get-buffer-create buffer)函数要么获得已经命名的缓冲区，要么用给定的名字创建一个缓冲区。
(insert-buffer-substring oldbuf start end)函数从作为其第一个参量指定的缓冲区中拷贝一个字符串，并将其插入到当前的缓冲区中。
(insert-buffer-substring)函数执行完之后，save-excursion将恢复对原来缓冲区的操作，并且append-to-buffer将完成其工作。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-5&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.5&lt;/span&gt; 回顾&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-5&quot;&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;find-tag
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
找到某个函数或者变量的源代码的文件，并切换到这个缓冲区，将位点（光标）置于相应函数或者变量的开始处。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;set-buffer
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
将Emacs的注意力转移到另一个缓冲区，但是不改变显示的窗口。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 20 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/emacs/lisp/2014/10/20/gnu%20emacs%20lisp%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/emacs/lisp/2014/10/20/gnu%20emacs%20lisp%20%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html</guid>
        
        <category>lisp</category>
        
        
        <category>emacs</category>
        
        <category>lisp</category>
        
      </item>
    
      <item>
        <title>GNU Emacs Lisp编程入门笔记（二）</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第2章 求值实践&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. 缓冲区名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. 获得缓冲区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 切换缓冲区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. 缓冲区大小和位点的定位&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第2章 求值实践&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; 缓冲区名&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
缓冲区和文件是不同的概念。文件是永久保存在计算机中的信息。缓冲区则是Emacs内部的信息，如果不保存，则Emacs关闭后缓冲区中的内容将消失。
打开Emacs,在&quot;&lt;b&gt;scratch&lt;/b&gt;&quot;缓冲区中对(buffer-name)求值将显示&quot;&lt;b&gt;scratch&lt;/b&gt;&quot;，对&quot;(buffer-file-name)&quot;进行求值则会显示&quot;nil&quot;。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; 获得缓冲区&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
buffer-name函数返回缓冲区的名字。
current-buffer函数获得缓冲区本身。
other-buffer函数返回最近使用过的缓冲区。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 切换缓冲区&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
当other-buffer函数被一个函数用作参量时，通过switch-to-buffer加上other-buff函数可以切换到另外一个缓冲区。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(switch-to-buffer (other-buffer))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
在实际应用中用到更多的函数是set-buffer。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; 缓冲区大小和位点的定位&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;buffer-size函数。这个函数给出当前缓冲区的大小，即缓冲区中字符数的计数。
&lt;/li&gt;
&lt;li&gt;point函数。返回光标所处位置，即从缓冲区首字符到光标所在位置之间的字符数。
&lt;/li&gt;
&lt;li&gt;point-min函数。返回当前缓冲区中位点的最小可能值。一般是1。
&lt;/li&gt;
&lt;li&gt;point-max函数。返回当前缓冲区中位点的最大可能值。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 19 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/emacs/lisp/2014/10/19/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/emacs/lisp/2014/10/19/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</guid>
        
        <category>emacs</category>
        
        
        <category>emacs</category>
        
        <category>lisp</category>
        
      </item>
    
      <item>
        <title>GNU Emacs Lisp编程入门笔记（三）</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第3章 如何编写函数定义&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. defun特殊表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. 安装函数定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 使函数成为交互函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. interactive函数的不同选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5&quot;&gt;1.5. 永久地安装代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6&quot;&gt;1.6. let函数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6-1&quot;&gt;1.6.1. let表达式的各个部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6-2&quot;&gt;1.6.2. let表达式例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6-3&quot;&gt;1.6.3. let语句中的未初始化变量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-7&quot;&gt;1.7. if特殊表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-8&quot;&gt;1.8. if-then-else表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-9&quot;&gt;1.9. Lisp中的真和假&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-10&quot;&gt;1.10. save-excursion函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-11&quot;&gt;1.11. 小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第3章 如何编写函数定义&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;/div&gt;&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; defun特殊表&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
在Lisp中，一个类似于mark-whole-buffer这样的符号已经有代码与之联系了，这告诉计算机当函数被调用时要做些什么。该代码被称作函数定义，它是通过对一个以符号defun开头的Lisp表达式求值而被建立的。因为defun不以通常的方式对它的参量求值，因此它被称为特殊表。
一个函数定义在defun符号之后最多有五个部分：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;符号名，这是函数定义将要依附的符号。
&lt;/li&gt;
&lt;li&gt;将要传送给函数的参量列表。如果无参量，那就是空列表（）。
&lt;/li&gt;
&lt;li&gt;描述这个函数的文档。
&lt;/li&gt;
&lt;li&gt;一个使函数成为交互函数的表达式，这是可选的。因此，可以通过键入M-x和函数名来使用它，或者键入一个事先设定的快捷键。
&lt;/li&gt;
&lt;li&gt;指导计算机如何运行的代码，这是函数定义的主体。
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;function-name&lt;/span&gt; (arguments...)
    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;optional-documentation...&quot;&lt;/span&gt;
    (interactive argument-passing-info) &lt;span style=&quot;color: #ffd700;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;optional&lt;/span&gt;
    body...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
例子：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;multiply-by-seven&lt;/span&gt; (number)
    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Multiply NUMBER by seven.&quot;&lt;/span&gt;
    (* 7 number))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; 安装函数定义&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
对函数求值（即运行它，光标移到函数末尾执行C-j或者C-c C-e）将返回函数本身，这一动作就是函数的安装。不过这是临时安装，Emacs关闭后这个函数也将失去。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 使函数成为交互函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
使一个函数成为交互函数可以这样实现：在函数文档后面增加一个以特殊表interactive开始的列表。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;multiply-by-seven&lt;/span&gt; (number)
    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Multiply NUMBER by seven.&quot;&lt;/span&gt;
    (interactive &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;p&quot;&lt;/span&gt;)
    (message &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;The result is %d.&quot;&lt;/span&gt; (* 7 number)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
message是一个Emacs Lisp函数（应该可以叫库函数吧，就如printf）。其作用是将一行消息传递给用户。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; interactive函数的不同选项&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
在上面的例子中，myltiply-by-seven函数使用&quot;p&quot;作为交互命令interactive的参量。这个参量告诉Emacs将你正在键入的C-u加上一个数字或META加上一个数字解释为一个命令，用来将这个数字作为参量传递给函数。Emacs有多于20个为interactive预先定义好的字符。interactive可以有多个参量。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;name-of-function&lt;/span&gt; (buffer start end)
    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;documentation...&quot;&lt;/span&gt;
    (interactive &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;BAppend to buffer: \nr&quot;&lt;/span&gt;)
    boy-of-function...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-5&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.5&lt;/span&gt; 永久地安装代码&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-5&quot;&gt;
&lt;p&gt;
永久安装代码有三种办法：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;个人使用，可以写入.emacs中。
&lt;/li&gt;
&lt;li&gt;可以将函数定义放在一个或多个文件中（一般以el作为后缀），然后使用load函数让Emacs对它们求值。
&lt;/li&gt;
&lt;li&gt;所有用户使用的，一般将它放在site-init.el文件中，它在Emacs启动时被加载。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-6&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-6&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.6&lt;/span&gt; let函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-6&quot;&gt;
&lt;p&gt;
let是一个特殊表，用于将一个符号绑定到一个值上。可以理解为声明局部变量，它的作用域为let表达式。
let可以创建一个或多个变量。也可给每一个变量赋初值。初值可以是数字、字符串或nil(空)。
let表达式返回值为表达式主体中最后一个表达式的值。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-6-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-6-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.6.1&lt;/span&gt; let表达式的各个部分&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-6-1&quot;&gt;
&lt;p&gt;
let表达式是一个具有三个部分的列表。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;let符号
&lt;/li&gt;
&lt;li&gt;列表，称为变量列表(varlist),这个列表的每个元素是一个符号或一个两元素的列表，而它的第一个元素一定是一个符号。
&lt;/li&gt;
&lt;li&gt;表达式主体，由一个或多个列表组成。
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
let表达式的模板如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; varlist body...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
如果变量列表是由两元素列表组成，其模板如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; ((variable value)
     (variable value)
     ...)
     body...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-6-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-6-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.6.2&lt;/span&gt; let表达式例子&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-6-2&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; ((zebra &#39;stripes)
      (tiger &#39;fierce))
    (message &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;One kind of animal has %s and another is %s.&quot;&lt;/span&gt; 
         zebra tiger))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-6-3&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-6-3&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.6.3&lt;/span&gt; let语句中的未初始化变量&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-6-3&quot;&gt;
&lt;p&gt;
如果let语句中未对变量赋初值，则默认为nil。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; ((birch 3)
      pine
      fir
      (oak &#39;some))
    (message
     &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Here are %d variables with %s, %s, and %s value.&quot;&lt;/span&gt;
      birch pine fir oak))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-7&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-7&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.7&lt;/span&gt; if特殊表&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-7&quot;&gt;
&lt;p&gt;
if是个条件特殊表。编写一个if表达式时，真假测试经常与if写在同一行，执行语句则另起一行。
例子:
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;type-of-animal&lt;/span&gt; (characteristic)
    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Print message in echo area depending on CHARACTERISTIC.&lt;/span&gt;
&lt;span style=&quot;color: #ffa500;&quot;&gt;    If the CHARACTERISTIC is the symbol &#39;fierce&#39;,&lt;/span&gt;
&lt;span style=&quot;color: #ffa500;&quot;&gt;    then warn of a tiger.&quot;&lt;/span&gt;
    (&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; (equal characteristic &#39;fierce)
        (message &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;It&#39;t a tiger&quot;&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
在Lisp中，equal是判定它的第一个参量是否等于第二个参量的函数。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-8&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-8&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.8&lt;/span&gt; if-then-else表达式&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-8&quot;&gt;
&lt;p&gt;
在elisp中，if-then-else判断只出现if,默认第二个参量为then部，第三个为else部。else部的缩进比then部的小。
模板如下：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; true-or-false-test
    (action-to-carry-out-if-the-test-returns-true)
  (action-to-carry-out-if-the-test-returns-false))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
例子：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;let&lt;/span&gt; ((zebra &#39;stripes)
      (tiger &#39;fierce)))

(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;type-of-animal&lt;/span&gt; (char) &lt;span style=&quot;color: #ffd700;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color: #ffd700;&quot;&gt;second version&lt;/span&gt;
    (&lt;span style=&quot;color: #00ffff;&quot;&gt;if&lt;/span&gt; (equal char &#39;fierce)
        (message &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;It&#39;s a tiger&quot;&lt;/span&gt;)
      (message &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;It&#39;s not fierce!&quot;&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-9&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-9&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.9&lt;/span&gt; Lisp中的真和假&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-9&quot;&gt;
&lt;p&gt;
如果值为nil，则为假。非nil,则为真。在Lisp中，nil有两种含义，一为假，一为空列表()。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-10&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-10&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.10&lt;/span&gt; save-excursion函数&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-10&quot;&gt;
&lt;p&gt;
这个函数是将当前的位点和标记保存起来，执行函数体，然后，如果位点和标记发生改变就将位点和标记恢复成原来的值。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;复习：&lt;/b&gt;
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;位点：就是光标所处的位置。光标在什么位置，位点就是光标的前一位。位点是个整数。位点(point)函数返回光标的当前位置，每一个缓冲区都有它的位点。
&lt;/li&gt;
&lt;li&gt;标记：是缓冲区的另外一个位置。它的值可以用set-mark-command来设置。
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
位点和标记之间的缓冲区称为区域(region)。save-excursion特殊表可以将位点和标记的当前位置保存起来，并当特殊表主体代码由Lisp解释器执行完毕后恢复到原来的位点和标记的位置。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-11&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-11&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.11&lt;/span&gt; 小结&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-11&quot;&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;defun
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
定义函数。最多可以有5个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(&lt;span style=&quot;color: #00ffff;&quot;&gt;defun&lt;/span&gt; &lt;span style=&quot;color: #00fa9a;&quot;&gt;back-to-indentation&lt;/span&gt; ()
    &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;Point to first visible character on line.&quot;&lt;/span&gt;
    (interactive)
    (beginning-of-line 1)
    (skip-chars-forward &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot; \t&quot;&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;interactive
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
向Lisp解释器声明这个函数可以被交互地使用。这个特殊表可以用一个字符串，分成一个部分或几个部分，依次传递信息到这个函数的参数。这些部分也可以告诉Lisp解释器提示这些信息。字符串的每一个部分用换行符&quot; \n&quot;分开。
其中常用到的控制字符是：
b 一个已经存在的缓冲区的名字
f 一个已经存在的文件的名字
p 数字前缀参量
r 位点和标记，作为两个数字参量，小的在前。这是唯一定义两个连续参量而不是一个参量的控制符。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;let
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
声明在let表达式主体中使用的变量列表并给它们赋初值，初值要么是nil,要么是一个指定的值。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;save-excursion
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
在对这个特殊表主体求值前，记录位点和标记的值以及当前缓冲区。求值之后恢复原来的位点和标记。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(message &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;We are %d characters into this buffer.&quot;&lt;/span&gt;
        (- (point)
            (&lt;span style=&quot;color: #00ffff;&quot;&gt;save-excursion&lt;/span&gt;
                (goto-char (poing-min)) (poing))))
&lt;/pre&gt;
&lt;/div&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;if
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
对函数的第一个参量求值;如果为真，则对第二个参量求值;否则，如果有第三个参量，就对第三个参量求值。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;equal和eq
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
测试两个对象是否相同。如果两个对象有相似的结构和内容，equal则返回“真”。如果两个参量确实是完全相同的对象，则另一个函数eq返回“真”。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&amp;lt; 、 &amp;gt; 、&amp;lt;= 、 &amp;gt;=
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
这个比较容易理解。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;message
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
用于回显区打印一条消息。打印消息只可以有一行。可以包含%s、%d、%c。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;setq、set
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
setq函数将其第一个参量的值设为第二个参量的值。这个函数对后续的成对参量执行相同的赋值操作。set函数则只接受两个参量，并且第二个参量前要加单引号。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;buffer-name
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
这个函数不需要参量，返回缓冲区的名字。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;buffer-file-name
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
这个函数也不需要参量，返回当前缓冲区正在访问的文件的名字
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;current-buffer
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
返回Emacs中当前缓冲区的名字，这个缓冲区可能并不是屏幕上看到的缓冲区。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;other-buffer
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
返回最近选择过的缓冲区。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;switch-to-buffer
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
这个函数为Emacs选择一个活动的缓冲区，并将它显示在当前的窗口。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;set-buffer
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
将Emacsr注意力切换到另外一个运行程序的缓冲区。不要改变当前窗口正在显示的内容。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;buffer-size
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
返回当前缓冲区中的字符数。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;point
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
返回当前光标对应的值，这个值是从缓冲区的开始处直到光标所在位置所占的总字符数。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;point-min
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
返回当前缓冲区中位点的最小可能值，如果变窄没有开启，这个值就是1。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;point-max
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
返回当前缓冲区中位点的最大可能值。如果变窄没有开启，这个值就是缓冲区末尾对应的值。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;eval-last-sexp
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
对光标所处的位点前的最后一个符号表达式求值。如果这个函数被激活时没有带参量，返回输出在回显区中。如果这个函数被激活时带有参量，其输出打印在当前缓冲区中。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 19 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/emacs/lisp/2014/10/19/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/emacs/lisp/2014/10/19/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89.html</guid>
        
        <category>emacs</category>
        
        
        <category>emacs</category>
        
        <category>lisp</category>
        
      </item>
    
      <item>
        <title>GNU Emacs Lisp 编程入门笔记（一)</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 第1章 列表处理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1&quot;&gt;1.1. Lisp列表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-1&quot;&gt;1.1.1. Lisp原子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-2&quot;&gt;1.1.2. 列表中的空格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-1-3&quot;&gt;1.1.3. GNU Emacs帮助你输入列表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-2&quot;&gt;1.2. 运行一个程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-3&quot;&gt;1.3. 产生错误的消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-4&quot;&gt;1.4. 符号名和函数定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-5&quot;&gt;1.5. Lisp解释器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-6&quot;&gt;1.6. 求值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-7&quot;&gt;1.7. 变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-8&quot;&gt;1.8. 参量&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-8-1&quot;&gt;1.8.1. 参量的数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-8-2&quot;&gt;1.8.2. 作为变量和列表的值的参量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-8-3&quot;&gt;1.8.3. 可变参量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-9&quot;&gt;1.9. 给一个变量赋值&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-9-1&quot;&gt;1.9.1. 使用set函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-9-2&quot;&gt;1.9.2. 使用setq函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-9-3&quot;&gt;1.9.3. 计数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1-10&quot;&gt;1.10. 小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 第1章 列表处理&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
Lisp是指&quot;LISt Processing&quot;(列表处理)。是一种通过把列表放置在括号中进行处理的编程语言。
列表是Lisp的基础。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.1&lt;/span&gt; Lisp列表&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;
&lt;p&gt;
&lt;b&gt;列表的基本样式&lt;/b&gt;
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&#39;(rose violet daisy buttercup)
&lt;/li&gt;
&lt;li&gt;(+ 2 2)
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;b&gt;列表可以嵌套&lt;/b&gt;
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-n&quot;&gt;&#39;(this is has (a list inside of it))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-1-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.1&lt;/span&gt; Lisp原子&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-1&quot;&gt;
&lt;p&gt;
Lisp原子，不可分的元素。原子有以下几种：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;数字。比如 &quot;35&quot; &quot;511&quot;
&lt;/li&gt;
&lt;li&gt;符号。比如 &quot;+&quot; &quot;foo&quot; &quot;forward-line&quot;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
双引号中的文本，不论是句子或者段落都是一个原子。
列表有三种组成方式：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;括号和原子
&lt;/li&gt;
&lt;li&gt;括号和列表
&lt;/li&gt;
&lt;li&gt;括号和其他列表及原子
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
原子和列表的书面表示都被称作符号表达式，s-表达式（s-expression）。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-1-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.2&lt;/span&gt; 列表中的空格&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-2&quot;&gt;
&lt;p&gt;
列表中的原子以空格分隔，多个空格只等同于一个。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-1-3&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-1-3&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.1.3&lt;/span&gt; GNU Emacs帮助你输入列表&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-1-3&quot;&gt;
&lt;p&gt;
TAB键和M-C-\自动缩排,有助于程序结构更加清晰。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.2&lt;/span&gt; 运行一个程序&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;
&lt;p&gt;
在emacs书写elisp程序的步骤：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;打开emacs
&lt;/li&gt;
&lt;li&gt;M-x 键入lisp-interaction-mode
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
就可进入lisp mode，进行程序书写。
Lisp中任何列表都是一个可运行的程序。要运行该列表，先把光标放置于列表之后，键入C-j或者C-x C-e就可以了。
运行他，计算机将完成三件事情：
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;只返回列表
&lt;/li&gt;
&lt;li&gt;告诉你一个出错消息
&lt;/li&gt;
&lt;li&gt;将列表中的第一个符号当作一个命令，然后执行这个命令。
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
单引号&quot; &#39; &quot;，被称作一个引用（quote）。当单引号位于一个列表之前时，它告诉Lisp不要对这个列表做任何操作。如果列表前没有单引号，那么列表的第一个符号就是一条计算机可以执行的命令。
（+ 2 2 ）这个列表前没有引号，所以+号就是命令，执行2+2。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.3&lt;/span&gt; 产生错误的消息&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;
&lt;p&gt;
运行程序时，如果发生错误，错误信息会在mini-buffer中显示。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-4&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.4&lt;/span&gt; 符号名和函数定义&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-4&quot;&gt;
&lt;p&gt;
在Lisp中，一组指令可以连到几个名字，例如加法指令可以连接到符号&quot;Plus&quot;，也可连接到符号&quot;+&quot;。另一方面，一个符号一次只能有一个函数定义与其相连。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-5&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.5&lt;/span&gt; Lisp解释器&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-5&quot;&gt;
&lt;p&gt;
&lt;b&gt;Lisp工作方式&lt;/b&gt;
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;首先，它一列表前面是否有单引号。如有，就给出这个列表。
&lt;/li&gt;
&lt;li&gt;其次，列表前无单引号，就查看列表第一个元素，判断其是否是一个函数定义。如进，则解释执行函数定义中的指令。否则就打印条错误消息。
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Lisp解释嵌套列表是由内往外执行的。
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;字节编译&lt;/b&gt;
运行编译命令(byte-compile-file)可以将.el代码编译成字节编码(.elc)。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-6&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-6&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.6&lt;/span&gt; 求值&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-6&quot;&gt;
&lt;p&gt;
当Lisp解释器处理一个表达式时，这个动作被称作“求值”。求值总是从内部列表开始，逐层往外进行。求值会返回一个值，同时可能产生一个附带效果，不然，就产生一个错误消息。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-7&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-7&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.7&lt;/span&gt; 变量&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-7&quot;&gt;
&lt;p&gt;
有值的可变的符号称作变量。变量应该赋值。如试图对一个没有赋值的变量求值，将收到一个错误消息（Symbol&#39;s value as variable is void: ）。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-8&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-8&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.8&lt;/span&gt; 参量&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-8&quot;&gt;
&lt;p&gt;
传递给函数的信息被称作参量。相当于C语言的实参吧。在Lisp中，一个函数的参量是函数后面的原子或者列表。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-8-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-8-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.8.1&lt;/span&gt; 参量的数据类型&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-8-1&quot;&gt;
&lt;p&gt;
传递给函数的参量的数据类型取决于它使用什么信息。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;像“+”函数，其参量必须是数字类型的值。
&lt;/li&gt;
&lt;li&gt;像“concat”函数（连接两个或多个字符串的函数），其参量必须是字符串。
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(concat &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;abc&quot;&lt;/span&gt; &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;def&quot;&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
求值结果为：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;&lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;abcdef&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;有些函数（如substring）,其参量既有字符串也有数字。
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(substring &lt;span style=&quot;color: #ffa500;&quot;&gt;&quot;The quick brown fox jumped.&quot;&lt;/span&gt; 16 19)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
求值结果为
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;fox
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-8-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-8-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.8.2&lt;/span&gt; 作为变量和列表的值的参量&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-8-2&quot;&gt;
&lt;p&gt;
参量可以是一个符号。对这个符号求值将返回一个值。例如：
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(+ 2 fill-column)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
返回74。(不同机器可能值不同，因fill-column值不同。)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-8-3&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-8-3&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.8.3&lt;/span&gt; 可变参量&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-8-3&quot;&gt;
&lt;p&gt;
Lisp可变参量很简单。比如：
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
(+ 3)
(+ 3 4 5 6)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-9&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-9&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.9&lt;/span&gt; 给一个变量赋值&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-9&quot;&gt;
&lt;p&gt;
给参量赋值可使用“set” “setq” “let”函数。
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-9-1&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-9-1&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.9.1&lt;/span&gt; 使用set函数&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-9-1&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(set &#39;flowers &#39;(rose violet daisy buttercup))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
使用set函数给变量赋值时应在列表前加单引号(&quot; &#39; &quot;)。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-9-2&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-9-2&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.9.2&lt;/span&gt; 使用setq函数&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-9-2&quot;&gt;
&lt;p&gt;
使用setq函数时，第一个参量不必加单引号。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(setq  flowers &#39;(rose violet daisy buttercup))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
setq同样可以为多个变量赋值。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(setq trees &#39;(pine fir oak maple)
      herbivores &#39;(gazelle antelope zebra))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-9-3&quot; class=&quot;outline-4&quot;&gt;
&lt;h4 id=&quot;sec-1-9-3&quot;&gt;&lt;span class=&quot;section-number-4&quot;&gt;1.9.3&lt;/span&gt; 计数&lt;/h4&gt;
&lt;div class=&quot;outline-text-4&quot; id=&quot;text-1-9-3&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-lisp&quot;&gt;(setq count 0)
(setq count (+ count 1))
count
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-1-10&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-10&quot;&gt;&lt;span class=&quot;section-number-3&quot;&gt;1.10&lt;/span&gt; 小结&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-10&quot;&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;Lisp程序由表达式组成，表达式是列表或单个原子。
&lt;/li&gt;
&lt;li&gt;列表由0个或多个原子或内部列表组成，原子或列表之间用空格分隔，并由括号括起来。列表可以是空的。
&lt;/li&gt;
&lt;li&gt;原子是多字符的符号(如forward-paragraph)、单字符符号(如＋)、双引号之间的字符串、或者数字。
&lt;/li&gt;
&lt;li&gt;对数字求值就是它本身。
&lt;/li&gt;
&lt;li&gt;对双引号之间的字符串求值也是其本身。
&lt;/li&gt;
&lt;li&gt;当对一个符号求值时，返回它的值。
&lt;/li&gt;
&lt;li&gt;对一个列表求值时，Lisp解数器查看列表中的第一个符号以及绑定在其上的函数定义。然后这个函数定义中的指令将被执行。
&lt;/li&gt;
&lt;li&gt;单引号告诉Lisp解释器返回后续表达式的字面值。
&lt;/li&gt;
&lt;li&gt;参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。
&lt;/li&gt;
&lt;li&gt;当对一个函数求值时总是返回一个值（除非是一个错误消息）。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 18 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/emacs/lisp/2014/10/18/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</link>
        <guid isPermaLink="true">http://xep007.github.io/emacs/lisp/2014/10/18/gnu%20emacs%20lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</guid>
        
        <category>emacs</category>
        
        
        <category>emacs</category>
        
        <category>lisp</category>
        
      </item>
    
      <item>
        <title>用org-capture-templates创建带时间戳的文档</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 创建符合jekyll要求的yaml格式的文件很麻烦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. 我的org-capture templates配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. 如何使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4&quot;&gt;4. 存在的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-5&quot;&gt;5. 问题的解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 创建符合jekyll要求的yaml格式的文件很麻烦&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
自从使用orgmode和jekyll写博客后，最麻烦的事就是用(C-x C-f)新建一个文档时得按&quot;y-m-d-文档名.org&quot;格式输入文件名。org-octopress倒是做得不错，功能齐全，不但可以新建“日期+文档名.org”的文档，还可以自行选择日期；不仅如此，它还能编辑和删除已存在的文档。org-jekyll-mode也很好，虽然功能不如org-octopress那么多。但是这两个插件都需要下载并配置。而我只想方便地创建带时间戳的文件，因而并未采用这两个插件。我就到网上四处搜寻，功夫不负有心人，终于找到了两篇文档，利用自定义org-capture templates很笨拙地解决了问题。
&lt;/p&gt;

&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;&lt;a href=&quot;http://www.robsyme.com/blog/2013/04/27/Blogging-from-your-text-editor-with-orgmode-and-middleman/&quot;&gt;http://www.robsyme.com/blog/2013/04/27/Blogging-from-your-text-editor-with-orgmode-and-middleman/&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://orgmode.org/manual/Capture-templates.html&quot;&gt;http://orgmode.org/manual/Capture-templates.html&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; 我的org-capture templates配置&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
上面提到的两篇文档都很简略，第一篇给出的代码是层递创建以日期分割的文件夹，然后在最后一个文件夹里创建index.org文件。第二个文档并未给出创建带日期的文件的方法。我瞎试着修改第一个文档给出的代码，得到如下配置。把以下代码写入&quot;.emacs&quot;。
&lt;/p&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-emacs&quot;&gt;;;;;org-capture-templates
(setq org-capture-templates
      &#39;((&quot;t&quot; &quot;Todo&quot; entry (file+headline &quot;~/org/notes/gtd.org&quot; &quot;Tasks&quot;)
	 &quot;* TODO %?\n  %i\n  %a&quot;)
	(&quot;b&quot; &quot;Blog draft&quot; entry (file (create-new-post &quot;~/org/documents/&quot;)))
	(&quot;j&quot; &quot;Journal&quot; entry (file+datetree+prompt &quot;~/org/notes/journal.org&quot;)
	 &quot;* %?\n -- %T\n&quot;)))

(defun create-new-post (base-path)
  (let* ((date (org-read-date &quot;&quot; &#39;totime nil nil (current-time) &quot;&quot;)) 
	 (title (read-string &quot;Post title: &quot;))                       
	 (path (format &quot;%s%s-%s.org&quot; base-path (format-time-string &quot;%Y-%m-%d&quot;) title))) 
    (make-directory (file-name-directory path) t)
    path))

(define-key global-map &quot;\C-cc&quot; &#39;org-capture)
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
列表中的“t”和&quot;j&quot;没用，因为我没有用todo来做gtd。列表中的&quot;b&quot;，表示blog,create-new-post后面的地址为存放org文件的目录，请改为你自己的。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; 如何使用&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
打开emacs,按下快捷键(C-cc),跳出一个日期表，默认选中当天，回车。接着输入文件名(不用输入org后缀)，回车。然后开始写博文，最后保存。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;4&lt;/span&gt; 存在的问题&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;p&gt;
利用org-capture templates来创建带时间戳的文件是取巧的办法。我使用之后，发现存在两个问题，不知如何解决。请大大教我。
&lt;/p&gt;
&lt;ul class=&quot;org-ul&quot;&gt;
&lt;li&gt;创建文件后打开的窗口只有整个窗口的一半，除了手动杀死另一个窗口之外，不知有什么办法。
&lt;/li&gt;
&lt;li&gt;创建新文件后，文件头有一个*号，除了手工删除，不知还有什么别的办法。
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;5&lt;/span&gt; 问题的解决&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;
&lt;p&gt;
哈哈，在不经意间，找到了《Linusp&#39;s blog》，然后找到他的&lt;a href=&quot;https://github.com/Linusp/Linusp.github.io&quot;&gt;Linusp.github.io&lt;/a&gt;项目。高手啊，很优雅地解决了这个问题。谢谢Linusp。看来，应该学一学elisp了。
Linusp的代码如下：
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
;; Write Blog
(defvar post-dir &quot;~/Dropbox/org/blog/_posts/&quot;)
(defun blog-post (title)
  (interactive &quot;sEnter title: &quot;)
  (let ((post-file (concat post-dir
                           (format-time-string &quot;%Y-%m-%d&quot;)
                           &quot;-&quot;
                           title
                           &quot;.org&quot;)))
    (progn
      (switch-to-buffer (find-file-noselect post-file))
      (insert (concat &quot;#+startup: showall\n&quot;
                      &quot;#+options: toc:nil\n&quot;
                      &quot;#+begin_html\n&quot;
                      &quot;---\n&quot;
                      &quot;layout     : post\n&quot;
                      &quot;title      : \n&quot;
                      &quot;categories : \n&quot;
                      &quot;tags       : \n&quot;
                      &quot;description: \n&quot;
                      &quot;---\n&quot;
                      &quot;#+end_html\n&quot;))))
  )
(define-key global-map &quot;\C-cp&quot; &#39;blog-post)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 17 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/org/jekyll/2014/10/17/%E7%94%A8org-capture-templates%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%96%87%E6%A1%A3.html</link>
        <guid isPermaLink="true">http://xep007.github.io/org/jekyll/2014/10/17/%E7%94%A8org-capture-templates%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%96%87%E6%A1%A3.html</guid>
        
        
        <category>org</category>
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>aptitude被锁定无法升级软件</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 解决办法1:温柔解决，不一定有效果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. 解决办法2：强制解锁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
今天sudo aptitude update时，终端提示如下错误：
&lt;/p&gt;

&lt;p&gt;
E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)
&lt;/p&gt;

&lt;p&gt;
E: 无法锁定管理目录(&lt;i&gt;var/lib/dpkg&lt;/i&gt;)，是否有其他进程正占用它？
&lt;/p&gt;

&lt;p&gt;
W: 无法锁定缓存文件；这通常意味着 dpkg 或另一个 apt 工具已经在安装软件包。正在以只读方式打开；您对软件包状态所作的任何改变都“不会”被保存！
&lt;/p&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 解决办法1:温柔解决，不一定有效果&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;p&gt;
运行ps ax,找出aptitude进程，杀死。我这边找不到aptitude相关进程，只好采用第二种办法。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; 解决办法2：强制解锁&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;pre class=&quot;example&quot;&gt;
sudo rm /var/cache/apt/archives/lock
sudo rm /var/lib/dpkg/lock
OK.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 12 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/linux/2014/10/12/aptitude%E8%A2%AB%E9%94%81%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</link>
        <guid isPermaLink="true">http://xep007.github.io/linux/2014/10/12/aptitude%E8%A2%AB%E9%94%81%E5%AE%9A%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</guid>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>org-jekyll-mode安装及配置</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 安装org-jekyll-mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. 设置org-jekyll-mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. 使用org-jekyll-mode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
前几天测试使用octopress创建github静态博客时，有个org-octopress的emacs插件非常好用。如今使用jekyll/bootstrap来建站，用emacs写博客就成了一个麻烦的问题。在github上找了一下，居然找到一个org-jekyll-mode，得好好试试。
&lt;/p&gt;
&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 安装org-jekyll-mode&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;div class=&quot;org-src-container&quot;&gt;

&lt;pre class=&quot;src src-git&quot;&gt;git clone https://github.com/jsuper/org-jekyll-mode org-jekyll-mode
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; 设置org-jekyll-mode&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;p&gt;
我把org-jekyll-mode文件夹拷贝到~/.emacs.d，然后按照作者主页(&lt;a href=&quot;http://jsuper.github.io/blog/using-org-mode-to-write-jekyll-post.html&quot;&gt;http://jsuper.github.io/blog/using-org-mode-to-write-jekyll-post.html&lt;/a&gt;)上的说明,在~/.emacs中加入以下设置。
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
(add-to-list &#39;load-path &quot;your-org-jekyll-mode-root&quot;)
(require &#39;org-jekyll-mode)
(setq org-jekyll/jekyll-project-root &quot;your-jekyll-root&quot;)
(setq org-jekyll/org-mode-project-root &quot;your-org-mode-project-root&quot;)
&lt;/pre&gt;

&lt;p&gt;
在使用org-jekyll-mode之前，你必须要先定义一些变量的值:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
org-jekyll/jekyll-project-root
&lt;/pre&gt;
&lt;p&gt;
这个变量指定了你的jekyll项目的根目录。因为org-jekyll-mode会根据这个路径，将其文件发布 到这个目录的相应子目录下。
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
org-jekyll/org-mode-project-root
&lt;/pre&gt;
&lt;p&gt;
该变量指定了你的org-mode文件存放的目录。一般我喜欢将我的文件放在一个单独的网盘里面， 这样方便管理和随时查看。
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
org-jekyll/org-mode-static-files-folder-name
&lt;/pre&gt;
&lt;p&gt;
这个变量指定了你在org-mode项目目录下，用于存放静态文件，如：图片、css等文件的目录名。 默认是你的org-mode项目的根目录。我个人比较喜欢将其放在一个叫assets的目录下。所以我的 org-mode 项目目录结构:
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
-Notes
 --assets
  ----img
  ----css
*.org
&lt;/pre&gt;
&lt;p&gt;
关于更多的介绍，请参见项目WIKI。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; 使用org-jekyll-mode&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
打开emacs,键入M-x，然后输入org-jekyll-mode,按照提示输入文件名。
以org-mode语法书写博客。以下是几个快捷键：
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
C-c C-d   创建新文件
&lt;/pre&gt;
&lt;pre class=&quot;example&quot;&gt;
C-c C-p   发布文件
&lt;/pre&gt;

&lt;p&gt;
不知道是不是安装的姿势不对，C-c C-p居然没反应。有空再好好看看。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/jekyll/org/2014/10/08/org-jekyll-mode%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE.html</link>
        <guid isPermaLink="true">http://xep007.github.io/jekyll/org/2014/10/08/org-jekyll-mode%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE.html</guid>
        
        
        <category>jekyll</category>
        
        <category>org</category>
        
      </item>
    
      <item>
        <title>debian7搭建hexo博客</title>
        <description>&lt;div id=&quot;table-of-contents&quot;&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=&quot;text-table-of-contents&quot;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sec-1&quot;&gt;1. 安装nodejs和npm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-2&quot;&gt;2. 安装hexo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-3&quot;&gt;3. 创建hexo文件夹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-4&quot;&gt;4. 安装依赖包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sec-5&quot;&gt;5. 本地预览&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;1&lt;/span&gt; 安装nodejs和npm&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;
&lt;pre class=&quot;example&quot;&gt;
sudo aptitude install nodejs npm
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;2&lt;/span&gt; 安装hexo&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;
&lt;pre class=&quot;example&quot;&gt;
sudo npm install -g hexo
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;3&lt;/span&gt; 创建hexo文件夹&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;
&lt;p&gt;
如果不在家目录建立文件夹，那么等下执行hexo init时会提示&quot;Error: Theme landscape does not exist.&quot;
&lt;/p&gt;

&lt;pre class=&quot;example&quot;&gt;
mkdir ~/hexo
&lt;/pre&gt;

&lt;p&gt;
进入hexo文件夹
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
cd hexo
hexo init
&lt;/pre&gt;
&lt;p&gt;
如果提示/usr/bin/env: node:没有那个文件或目录,就执行以下命令。然后再执行hexo init。
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
sudo ln -s /usr/bin/nodejs /usr/bin/node
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;4&lt;/span&gt; 安装依赖包&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;
&lt;pre class=&quot;example&quot;&gt;
npm install
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;outline-container-sec-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;&lt;span class=&quot;section-number-2&quot;&gt;5&lt;/span&gt; 本地预览&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;
&lt;p&gt;
与octopress大同小异。进入hexo文件夹，运行以下命令。然后就可以在浏览器中通过localhost:4000进行预览。
&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
hexo generate
hexo server
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://xep007.github.io/linux/hexo/2014/10/08/debian7%E6%9E%84%E5%BB%BAhexo+github%E5%8D%9A%E5%AE%A2.html</link>
        <guid isPermaLink="true">http://xep007.github.io/linux/hexo/2014/10/08/debian7%E6%9E%84%E5%BB%BAhexo+github%E5%8D%9A%E5%AE%A2.html</guid>
        
        
        <category>linux</category>
        
        <category>hexo</category>
        
      </item>
    
  </channel>
</rss>
